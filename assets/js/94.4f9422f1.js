(window.webpackJsonp=window.webpackJsonp||[]).push([[94],{418:function(t,n,e){"use strict";e.r(n);var v=e(0),_=Object(v.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("保存数据的方式")]),t._v(" "),e("p",[t._v("比如一组主题 themes的保存：")]),t._v(" "),e("blockquote",[e("p",[t._v("目标："),e("br"),t._v("\n1.减少http请求，不同方法中获取themes不用重复发送请求"),e("br"),t._v("\n2.任意位置(方法中)都可以很方便都获取单个数据，不用每次都从获取到的themes数组中单独处理")])]),t._v(" "),e("p",[t._v("1）page的data中-只要页面不重新初始化，数据就不会消失；"),e("br"),t._v("\n2）保存到小程序的缓存中；--管理很麻烦"),e("br"),t._v("\n3）保存到小程序的全局变量中，app.js文件中；--大材小用了"),e("br"),t._v("\n上述三种方式的缺点是只能保存一份themes，而且解决不了目标2的需求"),e("br"),t._v("\n4）类的对象本身就具有保存数据的功能，"),e("br"),t._v("\n类保存数据，但是类不能保存状态，但是类的对象既可以保存数据也可以保存状态；"),e("br"),t._v("\n比如："),e("br"),t._v("\nstatic locationA = 't-1' ，这就是类保存数据；"),e("br"),t._v("\nconst t = new Theme()"),e("br"),t._v("\nt.a = 1"),e("br"),t._v("\nconst t2 = new Theme()"),e("br"),t._v("\nt2.a = 2"),e("br"),t._v("\n同样属性，不同的对象，保存了两个数据的状态；"),e("br"),t._v("\n类不需要实例化，"),e("br"),t._v("\nTheme.a = 1"),e("br"),t._v("\nTheme.a = 2"),e("br"),t._v("\n从类上获取的a只会是2")]),t._v(" "),e("p",[t._v("解决思路：themes数据保存到对象中，在初始化页面到时候发送一次请求，"),e("br"),t._v("\n获取单个theme时，用保存到对象中到themes进行操作即可，封装方法，统一处理，使得每次调用简单方便")]),t._v(" "),e("p",[t._v("一个方法什么时候用static什么时候不加static？"),e("br"),t._v("\n考虑数据是否需要保存状态"),e("br"),t._v("\n原则：根据面向对象的本质 类和对象的功能"),e("br"),t._v("\n1.不保存，则使用static,类可以保存数据、不能保存状态"),e("br"),t._v("\n2.保存，则不用static,对象可以保存数据，也可以保存状态")])])}),[],!1,null,null,null);n.default=_.exports}}]);
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java源码及大厂真题 | 风间的技术栈</title>
    <meta name="description" content="风间的技术栈">
    <link rel="icon" href="/favicon.ico">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/assets/css/0.styles.a2aa872b.css" as="style"><link rel="preload" href="/assets/js/app.c5a7abc6.js" as="script"><link rel="preload" href="/assets/js/3.4c596803.js" as="script"><link rel="preload" href="/assets/js/1.bddbeb83.js" as="script"><link rel="preload" href="/assets/js/11.d44f14ae.js" as="script"><link rel="prefetch" href="/assets/js/10.b9d68160.js"><link rel="prefetch" href="/assets/js/100.047c29db.js"><link rel="prefetch" href="/assets/js/101.143fbd29.js"><link rel="prefetch" href="/assets/js/12.230614bb.js"><link rel="prefetch" href="/assets/js/13.cedaa4dd.js"><link rel="prefetch" href="/assets/js/14.cf0e86d9.js"><link rel="prefetch" href="/assets/js/15.30497c2f.js"><link rel="prefetch" href="/assets/js/16.e5093235.js"><link rel="prefetch" href="/assets/js/17.1c0bb9b2.js"><link rel="prefetch" href="/assets/js/18.041b0f6a.js"><link rel="prefetch" href="/assets/js/19.3d31afbb.js"><link rel="prefetch" href="/assets/js/20.62e7ec39.js"><link rel="prefetch" href="/assets/js/21.a727ec51.js"><link rel="prefetch" href="/assets/js/22.7663ae85.js"><link rel="prefetch" href="/assets/js/23.90b194e3.js"><link rel="prefetch" href="/assets/js/24.60f304ba.js"><link rel="prefetch" href="/assets/js/25.3b3f3077.js"><link rel="prefetch" href="/assets/js/26.445aa46b.js"><link rel="prefetch" href="/assets/js/27.a148d500.js"><link rel="prefetch" href="/assets/js/28.ac00ebe6.js"><link rel="prefetch" href="/assets/js/29.36277f2c.js"><link rel="prefetch" href="/assets/js/30.b34a9043.js"><link rel="prefetch" href="/assets/js/31.83e6de25.js"><link rel="prefetch" href="/assets/js/32.04609852.js"><link rel="prefetch" href="/assets/js/33.7c9cc307.js"><link rel="prefetch" href="/assets/js/34.86b4fa3e.js"><link rel="prefetch" href="/assets/js/35.945a10a3.js"><link rel="prefetch" href="/assets/js/36.4a2fefa0.js"><link rel="prefetch" href="/assets/js/37.db8fab65.js"><link rel="prefetch" href="/assets/js/38.c18d2543.js"><link rel="prefetch" href="/assets/js/39.9a53d85b.js"><link rel="prefetch" href="/assets/js/4.65f3738c.js"><link rel="prefetch" href="/assets/js/40.b1752d40.js"><link rel="prefetch" href="/assets/js/41.bda4942a.js"><link rel="prefetch" href="/assets/js/42.f6a5d44b.js"><link rel="prefetch" href="/assets/js/43.8eabaf46.js"><link rel="prefetch" href="/assets/js/44.7ebd052a.js"><link rel="prefetch" href="/assets/js/45.74f35983.js"><link rel="prefetch" href="/assets/js/46.c1f0d818.js"><link rel="prefetch" href="/assets/js/47.31b9563e.js"><link rel="prefetch" href="/assets/js/48.67f17f78.js"><link rel="prefetch" href="/assets/js/49.b5dea3a6.js"><link rel="prefetch" href="/assets/js/5.173246a3.js"><link rel="prefetch" href="/assets/js/50.444c1936.js"><link rel="prefetch" href="/assets/js/51.8a1ad4eb.js"><link rel="prefetch" href="/assets/js/52.0ac380dd.js"><link rel="prefetch" href="/assets/js/53.54ed521c.js"><link rel="prefetch" href="/assets/js/54.0786983c.js"><link rel="prefetch" href="/assets/js/55.eba2245f.js"><link rel="prefetch" href="/assets/js/56.600e56d5.js"><link rel="prefetch" href="/assets/js/57.2484f5da.js"><link rel="prefetch" href="/assets/js/58.f9ea2330.js"><link rel="prefetch" href="/assets/js/59.940305ce.js"><link rel="prefetch" href="/assets/js/6.45133ea5.js"><link rel="prefetch" href="/assets/js/60.a36d80c0.js"><link rel="prefetch" href="/assets/js/61.829e849f.js"><link rel="prefetch" href="/assets/js/62.ccfeca39.js"><link rel="prefetch" href="/assets/js/63.e87f3830.js"><link rel="prefetch" href="/assets/js/64.451902bc.js"><link rel="prefetch" href="/assets/js/65.c2c98a34.js"><link rel="prefetch" href="/assets/js/66.584bc155.js"><link rel="prefetch" href="/assets/js/67.8b4b06c0.js"><link rel="prefetch" href="/assets/js/68.27a9f48a.js"><link rel="prefetch" href="/assets/js/69.8f439f17.js"><link rel="prefetch" href="/assets/js/7.fbfec349.js"><link rel="prefetch" href="/assets/js/70.6898bb88.js"><link rel="prefetch" href="/assets/js/71.2bc4ebd7.js"><link rel="prefetch" href="/assets/js/72.90048a1e.js"><link rel="prefetch" href="/assets/js/73.04296406.js"><link rel="prefetch" href="/assets/js/74.6f05291d.js"><link rel="prefetch" href="/assets/js/75.39a8f362.js"><link rel="prefetch" href="/assets/js/76.97467347.js"><link rel="prefetch" href="/assets/js/77.bf5e40d5.js"><link rel="prefetch" href="/assets/js/78.1e1f0bd8.js"><link rel="prefetch" href="/assets/js/79.62f3c407.js"><link rel="prefetch" href="/assets/js/8.ec46c32b.js"><link rel="prefetch" href="/assets/js/80.d59ef904.js"><link rel="prefetch" href="/assets/js/81.5d0f60e0.js"><link rel="prefetch" href="/assets/js/82.4b41ea00.js"><link rel="prefetch" href="/assets/js/83.b6096561.js"><link rel="prefetch" href="/assets/js/84.da966883.js"><link rel="prefetch" href="/assets/js/85.355b804b.js"><link rel="prefetch" href="/assets/js/86.ff6ffbbb.js"><link rel="prefetch" href="/assets/js/87.4a2b3536.js"><link rel="prefetch" href="/assets/js/88.f9430200.js"><link rel="prefetch" href="/assets/js/89.d60f12d0.js"><link rel="prefetch" href="/assets/js/9.fe626446.js"><link rel="prefetch" href="/assets/js/90.9928bf5a.js"><link rel="prefetch" href="/assets/js/91.c9334031.js"><link rel="prefetch" href="/assets/js/92.d85956e2.js"><link rel="prefetch" href="/assets/js/93.0dd7bc12.js"><link rel="prefetch" href="/assets/js/94.4f9422f1.js"><link rel="prefetch" href="/assets/js/95.3425b4ed.js"><link rel="prefetch" href="/assets/js/96.975e7118.js"><link rel="prefetch" href="/assets/js/97.2dfa090c.js"><link rel="prefetch" href="/assets/js/98.f8bd4057.js"><link rel="prefetch" href="/assets/js/99.ac340a2c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a2aa872b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="theme-container" data-v-4698c43e><div data-v-4698c43e><div id="loader-wrapper" class="loading-wrapper" data-v-4b73742e data-v-4698c43e data-v-4698c43e><div class="loader-main" data-v-4b73742e><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div><div data-v-4b73742e></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-6cbeab0a data-v-4698c43e data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a>风间的技术栈</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>风间</span>
            
          <span data-v-6cbeab0a>2019 - </span>
          2020
        </a></span></div></div> <div class="hide" data-v-4698c43e><header class="navbar" data-v-4698c43e><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/book.png" alt="风间的技术栈" class="logo"> <span class="site-name">风间的技术栈</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/python/" class="nav-link"><i class="iconfont undefined"></i>
  python
</a></li><li class="dropdown-item"><!----> <a href="/categories/魔方/" class="nav-link"><i class="iconfont undefined"></i>
  魔方
</a></li><li class="dropdown-item"><!----> <a href="/categories/小程序/" class="nav-link"><i class="iconfont undefined"></i>
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/categories/英语/" class="nav-link"><i class="iconfont undefined"></i>
  英语
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-4698c43e></div> <aside class="sidebar" data-v-4698c43e><div class="personal-info-wrapper" data-v-6c8ffc9c><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-6c8ffc9c> <h3 class="name" data-v-6c8ffc9c>
    风间
  </h3> <div class="num" data-v-6c8ffc9c><div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>90</h3> <h6 data-v-6c8ffc9c>文章</h6></div> <div data-v-6c8ffc9c><h3 data-v-6c8ffc9c>130</h3> <h6 data-v-6c8ffc9c>标签</h6></div></div> <hr data-v-6c8ffc9c></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/python/" class="nav-link"><i class="iconfont undefined"></i>
  python
</a></li><li class="dropdown-item"><!----> <a href="/categories/魔方/" class="nav-link"><i class="iconfont undefined"></i>
  魔方
</a></li><li class="dropdown-item"><!----> <a href="/categories/小程序/" class="nav-link"><i class="iconfont undefined"></i>
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/categories/英语/" class="nav-link"><i class="iconfont undefined"></i>
  英语
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java源码及大厂真题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#第1章-基础" class="sidebar-link">第1章 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_01-开篇词：为什么学习本专栏" class="sidebar-link">01 开篇词：为什么学习本专栏</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_02-string、long-源码解析和面试题" class="sidebar-link">02 String、Long 源码解析和面试题</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_03-java-常用关键字理解" class="sidebar-link">03 Java 常用关键字理解</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_04-arrays、collections、objects-常用方法源码解析" class="sidebar-link">04 Arrays、Collections、Objects 常用方法源码解析</a></li></ul></li><li><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#第2章-集合" class="sidebar-link">第2章 集合</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_05-arraylist-源码解析和设计思路" class="sidebar-link">05 ArrayList 源码解析和设计思路</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_06-linkedlist-源码解析" class="sidebar-link">06 LinkedList 源码解析</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_07-list-源码会问哪些面试题" class="sidebar-link">07 List 源码会问哪些面试题</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_08-hashmap-源码解析" class="sidebar-link">08 HashMap 源码解析</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_09-treemap-和-linkedhashmap-核心源码解析" class="sidebar-link">09 TreeMap 和 LinkedHashMap 核心源码解析</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_10-map源码会问哪些面试题" class="sidebar-link">10 Map源码会问哪些面试题</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_11-hashset、treeset-源码解析" class="sidebar-link">11 HashSet、TreeSet 源码解析</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_12-彰显细节：看集合源码对我们实际工作的帮助和应用" class="sidebar-link">12 彰显细节：看集合源码对我们实际工作的帮助和应用</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_13-差异对比：集合在-java-7-和-8-有何不同和改进" class="sidebar-link">13 差异对比：集合在 Java 7 和 8 有何不同和改进</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_14-简化工作：guava-lists-maps-实际工作运用和源码" class="sidebar-link">14 简化工作：Guava Lists Maps 实际工作运用和源码</a></li></ul></li><li><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#第3章-并发集合类" class="sidebar-link">第3章 并发集合类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_15-copyonwritearraylist-源码解析和设计思路" class="sidebar-link">15 CopyOnWriteArrayList 源码解析和设计思路</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_16-concurrenthashmap-源码解析和设计思路" class="sidebar-link">16 ConcurrentHashMap 源码解析和设计思路</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_17-并发-list、map源码面试题" class="sidebar-link">17 并发 List、Map源码面试题</a></li><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_18-场景集合：并发-list、map的应用场景" class="sidebar-link">18 场景集合：并发 List、Map的应用场景</a></li></ul></li><li><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#第4章-队列" class="sidebar-link">第4章 队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/views/Java/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98.html#_19-linkedblockingqueue-源码解析" class="sidebar-link">19 LinkedBlockingQueue 源码解析</a></li></ul></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-6cbeab0a data-v-4698c43e><h3 class="title" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a>Java源码及大厂真题</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><input type="password" value="" data-v-6cbeab0a> <span data-v-6cbeab0a>Konck! Knock!</span> <button data-v-6cbeab0a>OK</button></label> <div class="footer" style="display:none;" data-v-6cbeab0a data-v-6cbeab0a><span data-v-6cbeab0a><i class="iconfont reco-theme" data-v-6cbeab0a></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-6cbeab0a>vuePress-theme-reco</a></span> <span data-v-6cbeab0a><i class="iconfont reco-copyright" data-v-6cbeab0a></i> <a data-v-6cbeab0a><span data-v-6cbeab0a>风间</span>
            
          <span data-v-6cbeab0a>2019 - </span>
          2020
        </a></span></div></div> <div data-v-4698c43e><main class="page"><!----> <div class="page-title" style="display:none;"><h1>Java源码及大厂真题</h1> <hr> <div data-v-484a899e><i class="iconfont reco-account" data-v-484a899e><span data-v-484a899e>风间</span></i> <i class="iconfont reco-date" data-v-484a899e><span data-v-484a899e>2020-03-31</span></i> <i class="iconfont reco-eye" data-v-484a899e><!----></i> <i class="iconfont reco-tag tags" data-v-484a899e><span class="tag-item" data-v-484a899e>
      Java源码
    </span><span class="tag-item" data-v-484a899e>
      Java
    </span><span class="tag-item" data-v-484a899e>
      大厂真题
    </span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h2 id="第1章-基础"><a href="#第1章-基础" class="header-anchor">#</a> 第1章 基础</h2> <h3 id="_01-开篇词：为什么学习本专栏"><a href="#_01-开篇词：为什么学习本专栏" class="header-anchor">#</a> 01 开篇词：为什么学习本专栏</h3> <p><strong>不为了源码而读源码，只为了更好的实践</strong></p> <p><strong>阅读源码真的可以帮助你顺利过技术面，找到更好的工作</strong>。</p> <p>阅读源码还可以帮忙我们增加个人自信，学习其优良设计思想，总结出最优使用姿势，
避免踩坑，甚至针对工作中的痛点进行创新改造。</p> <p>而在实际工作中，你可能遇到过这些尴尬：</p> <ol><li>很多 API 的使用，需要先百度，然后再复制粘贴；</li> <li>针对不同的场景，不知道如何设计不同类型的线程池，对 API 的使用没有太多的场景经验总结；</li> <li>代码 review 的时候，提不出意见，自己的代码却常常被别人吐槽；</li> <li>对于工作中 API 使用不方便的地方，想优化，但不知其内部实现原理，不敢动手。</li></ol> <p>通过调查发现，能绕过以上尴尬的同学，多数都是阅读过 Java 源码、对 Java 底层的构造了如指掌的。
这些同学能写团队核心代码，能轻易看出代码漏洞，能总结出 Java 的设计思想，并运用到日常工作中。</p> <p><strong>所以说阅读 Java 源码，还能让我们结合场景熟练的使用 API，基于工作中使用痛点做一些源码创新，是成为团队核心的技术基础。</strong></p> <p>我现在陆续阅读过 Java 7、8 的源码几遍，一开始很难坚持，因为源码比较枯燥。首先不知道源码的整体架构，然后细节之处不知道为什么这么写，
但最终还是啃下来了，甚至喜欢了阅读源码，于是我在想，是不是可以把我的源码阅读经验和一线工作经验结合，
使本课程成为源码的阅读指南、面试指南和场景实战指南。</p> <p>为了大家更易阅读，在接下来的 40 课中，<strong>我们会先从实际的案例场景出发，对 Java 中 30+ 个核心类进行图文源码解析，并从中总结出设计思想、最优使用姿势和坑，最终以连环面试题进行巩固。</strong></p> <p>我们对于每个源码类的文章套路为：</p> <ol><li>怎么用：用场景来说明类的重要方法的使用技巧；</li> <li>为什么：源码解析其底层实现源码，复杂的源码会有动图解析；</li> <li>总结：总结出设计思想、最优使用姿势和坑，看看能否为工作中所用；</li> <li>面试题：总结出最新连环面试题，一题接着一题深入，可以作为面试官和面试者的面试指南。</li></ol> <p>本课程涉及到的 Java 知识非常齐全，主要有基础类、集合类、并发集合类、队列、线程、锁、线程池、Lambda 流等内容，
内容几乎涵盖了工作和面试的核心，如果你对这些源码都了如指掌，面试题再千变万化，你也能应对自如。</p> <p>学习本课程门槛较低，只需要你有一颗肯学习进步，希望成为 Java 技术专家的信心和决心即可。</p> <p>本课程会有源码的 GitHub，欢迎喜欢阅读源码的同学来创建自己的分支，一起来结伴阅读源码，写上自己的感悟互相交流。</p> <p>总之，我一定会把专栏写的通俗易懂，也希望面前的你通过阅读本课程，找到更好的工作，走上 Java 专家之路，成为更专业，更资深，更有影响力的技术实践创新者。</p> <h3 id="_02-string、long-源码解析和面试题"><a href="#_02-string、long-源码解析和面试题" class="header-anchor">#</a> 02 String、Long 源码解析和面试题</h3> <p><strong>引导语</strong></p> <p>String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，
看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。</p> <p><strong>1. String</strong></p> <p><strong>1.1 不变性</strong></p> <p>我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。
这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，
我们写个 demo 来演示一下。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">String</span> s <span class="token operator">=</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
   s <span class="token operator">=</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，
也就说 s =“world” 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，
debug 的截图显示内存地址已经被修改，两张截图如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/01.jpeg" alt="01"> <img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/02.jpeg" alt="02"></p> <p>我们从源码上查看一下原因：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
       <span class="token keyword">implements</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span><span class="token class-name">Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
       <span class="token comment">/** The value is used for character storage. */</span>
       <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>我们可以看出来两点：</p> <ol><li>String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，
都不会被继承覆写；</li> <li>String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，
也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。</li></ol> <p>以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。</p> <p>因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，如下面这种写法是不对的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">String</span> str <span class="token operator">=</span><span class="token string">&quot;hello world !!&quot;</span><span class="token punctuation">;</span>
   <span class="token comment">// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace(&quot;l&quot;,&quot;dd&quot;);</span>
   str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;dd&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>1.2 字符串乱码</strong></p> <p>在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，
到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，
并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。</p> <p>我们也写了一个 demo 来模仿一下字符串乱码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">String</span> str  <span class="token operator">=</span><span class="token string">&quot;nihao 你好 喬亂&quot;</span><span class="token punctuation">;</span>
   <span class="token comment">// 字符串转化成 byte 数组</span>
   <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">&quot;ISO-8859-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// byte 数组转化成字符串</span>
   <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 结果打印为：</span>
   nihao <span class="token operator">?</span><span class="token operator">?</span> <span class="token operator">?</span><span class="token operator">?</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，
是不是我把代码修改成 <code>String s2 = new String(bytes,&quot;ISO-8859-1&quot;);</code>
就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，
导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，
对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，
我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。</p> <p><strong>1.3 首字母大小写</strong></p> <p>如果我们的项目被 Spring 托管的话，有时候我们会通过 <code>applicationContext.getBean(className);</code> 这种方式得到 SpringBean，
这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：</p> <p><code>name.substring(0, 1).toLowerCase() + name.substring(1);</code>，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：</p> <ol><li><code>public String substring(int beginIndex, int endIndex)</code> beginIndex：开始位置，endIndex：结束位置；</li> <li><code>public String substring(int beginIndex)</code>beginIndex：开始位置，结束位置为文本末尾。</li></ol> <p>substring 方法的底层使用的是字符数组范围截取的方法 ：
<code>Arrays.copyOfRange(字符数组, 开始位置, 结束位置);</code> 从字符数组中进行一段范围的拷贝。</p> <p>相反的，如果要修改成首字母大写，只需要修改成 <code>name.substring(0, 1).toUpperCase() + name.substring(1)</code> 即可。</p> <p><strong>1.4 相等判断</strong></p> <p>我们判断相等有两种办法，equals 和 equalsIgnoreCase。后者判断相等时，
会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，
应该如何写，我们来一起看下 equals 的源码，整理一下思路：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 判断内存地址是否相同</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 待比较的对象是否是 String，如果不是 String，直接返回不相等</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
           <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
           <span class="token comment">// 两个字符串的长度是否相等，不等则直接返回不相等</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
               <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
               <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
               <span class="token comment">// 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span>
               <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                   i<span class="token operator">++</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。
这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，
这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，
判断相等时，就挨个比较 char 数组中的字符是否相等即可。</p> <p><strong>1.5 替换、删除</strong></p> <p>替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、
replaceFirst 替换遇到的第一个字符串三种场景。</p> <p>其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，
前者表示替换所有字符，如：<code>name.replace('a','b')</code>，后者表示替换所有字符串，
如：<code>name.replace(&quot;a&quot;,&quot;b&quot;)</code>，两者就是单引号和多引号的区别。</p> <p>需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。</p> <p>写了一个 demo 演示一下三种场景：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">String</span> str <span class="token operator">=</span><span class="token string">&quot;hello word !!&quot;</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;替换之前 :{}&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
     str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;替换所有字符 :{}&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
     str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">&quot;d&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;替换全部 :{}&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
     str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceFirst</span><span class="token punctuation">(</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;替换第一个 l :{}&quot;</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">//输出的结果是：</span>
   替换之前 <span class="token operator">:</span>hello word <span class="token operator">!</span><span class="token operator">!</span>
   替换所有字符 <span class="token operator">:</span>heddo word <span class="token operator">!</span><span class="token operator">!</span>
   替换全部 <span class="token operator">:</span>hello worl <span class="token operator">!</span><span class="token operator">!</span>
   替换第一个 <span class="token operator">:</span>helo worl <span class="token operator">!</span><span class="token operator">!</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。</p> <p><strong>1.6 拆分和合并</strong></p> <p>拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，
第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。
如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分，我们演示一个 demo：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">String</span> s <span class="token operator">=</span><span class="token string">&quot;boo:and:foo&quot;</span><span class="token punctuation">;</span>
   <span class="token comment">// 我们对 s 进行了各种拆分，演示的代码和结果是：</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;:&quot;</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;boo&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;:&quot;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;boo&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;and:foo&quot;</span><span class="token punctuation">]</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;:&quot;</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;boo&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;:&quot;</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;boo&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;and&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;foo&quot;</span><span class="token punctuation">]</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;:and:f&quot;</span><span class="token punctuation">]</span>
   s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;o&quot;</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;o:and:foo&quot;</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。</p> <p>那如果字符串里面有一些空值呢，拆分的结果如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">String</span> a <span class="token operator">=</span><span class="token string">&quot;,a,,b,&quot;</span><span class="token punctuation">;</span>
   a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，
所以推荐使用 Guava 的 API 对字符串进行分割。</p> <p>合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，
参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：</p> <ol><li>不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，
如果你这么写的话 <code>String.join(&quot;,&quot;,s).join(&quot;,&quot;,s1)</code> 最后得到的是 s1 的值，
第一次 join 的值被第二次 join 覆盖了；</li> <li>如果 join 的是一个 List，无法自动过滤掉 null 值。</li></ol> <p>而 Guava 正好提供了 API，解决上述问题，我们来演示一下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 依次 join 多个字符串，Joiner 是 Guava 提供的 API</span>
   <span class="token class-name">Joiner</span> joiner <span class="token operator">=</span> <span class="token class-name">Joiner</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skipNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">String</span> result <span class="token operator">=</span> joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token string">&quot;china&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;依次 join 多个字符串:{}&quot;</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;china&quot;</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;自动删除 list 中空值:{}&quot;</span><span class="token punctuation">,</span>joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 输出的结果为；</span>
   依次 join 多个字符串<span class="token operator">:</span>hello<span class="token punctuation">,</span>china
   自动删除 list 中空值<span class="token operator">:</span>hello<span class="token punctuation">,</span>china

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，
这就是我们在工作中常常需要得到的结果。</p> <p><strong>2 Long</strong></p> <p><strong>2.1 缓存</strong></p> <p>Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，
缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，
而是从缓存中拿，缓存初始化源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LongCache</span> <span class="token punctuation">{</span>
       <span class="token keyword">private</span> <span class="token class-name">LongCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
       <span class="token comment">// 缓存，范围从 -128 到 127，+1 是因为有个 0</span>
       <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Long</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   
       <span class="token comment">// 容器初始化时，进行加载</span>
       <span class="token keyword">static</span> <span class="token punctuation">{</span>
           <span class="token comment">// 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128</span>
           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
               cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>3 面试题</strong></p> <p><strong>3.1</strong> 为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法</p> <p>答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p> <p><strong>3.2</strong> 如何解决 String 乱码的问题</p> <p>答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：</p> <ol><li>所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；</li> <li>我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。</li></ol> <p><strong>3.3</strong> 为什么大家都说 String 是不可变的</p> <p>答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。</p> <p><strong>3.4</strong> String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题</p> <p>答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。</p> <p><strong>总结</strong></p> <p>String 和 Long 在我们工作中使用频率很高，在面试的过程中，考官也喜欢问一些关于实际操作的问题，
来考察我们的使用熟练度，所以本文中列举的一些 demo，大家可以试试手，
完整的代码可以去 GitHub 上面去拉取。</p> <h3 id="_03-java-常用关键字理解"><a href="#_03-java-常用关键字理解" class="header-anchor">#</a> 03 Java 常用关键字理解</h3> <p><strong>引导语</strong></p> <p>Java 中的关键字很多，大约有 50+，在命名上我们不能和这些关键字冲突的，编译会报错，
每个关键字都代表着不同场景下的不同含义，接下来我们挑选 6 个比较重要的关键字，深入学习一下。</p> <p><strong>1 static</strong></p> <p>意思是静态的、全局的，一旦被修饰，说明被修饰的东西在一定范围内是共享的，谁都可以访问，
这时候需要注意并发读写的问题。</p> <p><strong>1.1 修饰的对象</strong></p> <p>static 只能修饰类变量、方法和方法块。</p> <p><strong>当 static 修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，
而且无需初始化类，直接使用 <strong>类名.static</strong> 变量 这种形式访问即可。</p> <p>这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，
很有可能会出现并发问题，如我们定义了：<code>public static List&lt;String&gt; list = new ArrayList();</code>
这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，
这时候一般有两个解决办法：</p> <ol><li>把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；</li> <li>每次访问时，手动加锁。</li></ol> <p>所以在使用 static 修饰类变量时，如何保证线程安全是我们常常需要考虑的。</p> <p><code>当 static 修饰方法时</code>，代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p> <p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们常用的 util 类里面的各种方法，我们比较喜欢用 static 修饰方法，好处就是调用特别方便。</p> <p>static 方法内部的变量在执行时是没有线程安全问题的。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p> <p><code>当 static 修饰方法块时</code>，我们叫做静态块，静态块常常用于在类启动之前，初始化一些值，比如：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 进行一些初始化的工作</span>
   <span class="token keyword">static</span> <span class="token punctuation">{</span>
       list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这段代码演示了静态块做一些初始化的工作，但需要注意的是，静态块只能调用同样被 static 修饰的变量，
并且 static 的变量需要写在静态块的前面，不然编译也会报错。</p> <p><strong>1.2 初始化时机</strong></p> <p>对于被 static 修饰的类变量、方法块和静态方法的初始化时机，我们写了一个测试 demo，如下图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/03.jpeg" alt="03"></p> <p>打印出来的结果是：</p> <p>父类静态变量初始化
父类静态块初始化<br>
子类静态变量初始化
子类静态块初始化<br>
main 方法执行<br>
父类构造器初始化<br>
子类构造器初始化</p> <p>从结果中，我们可以看出两点：</p> <p>父类的静态变量和静态块比子类优先初始化；<br>
静态变量和静态块比类构造器优先初始化。<br>
被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p> <p><strong>2 final</strong></p> <p>final 的意思是不变的，一般来说用于以下三种场景：</p> <ol><li>被 final 修饰的类，表明该类是无法继承的；</li> <li>被 final 修饰的方法，表明该方法是无法覆写的；</li> <li>被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。</li></ol> <p>第三点注意下，我们说的是无法修改其内存地址，并没有说无法修改其值。
因为对于 List、Map 这些集合类来说，被 final 修饰后，是可以修改其内部值的，
但却无法修改其初始化时的内存地址。</p> <p>例子我们就不举了，1-1 小节 String 的不变性就是一个很好的例子。</p> <p><strong>3 try、catch、finally</strong>
这三个关键字常用于我们捕捉异常的一整套流程，try 用来确定代码执行的范围，
catch 捕捉可能会发生的异常，finally 用来执行一定要执行的代码块，
除了这些，我们还需要清楚，每个地方如果发生异常会怎么办，我们举一个例子来演示一下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCatchFinally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;try is run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;try exception&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;catch is run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;catch exception&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;finally is run&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>这个代码演示了在 try、catch 中都遇到了异常，代码的执行顺序为：try -&gt; catch -&gt; finally，输出的结果如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/04.jpeg" alt="04"></p> <p>可以看到两点：</p> <ol><li>finally 先执行后，再抛出 catch 的异常；</li> <li>最终捕获的异常是 catch 的异常，try 抛出来的异常已经被 catch 吃掉了，
所以当我们遇见 catch 也有可能会抛出异常时，我们可以先打印出 try 的异常，
这样 try 的异常在日志中就会有所体现。</li></ol> <p><strong>4 volatile</strong></p> <p>volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。</p> <p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU 缓存打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p> <p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p> <p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p> <p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p> <p>我们画了一个图来说明一下：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/05.jpeg" alt="05"></p> <p>从图中我们可以看到，线程 1 和线程 2 一开始都读取了 C 值，
CPU 1 和 CPU 2 缓存中也都有了 C 值，然后线程 1 把 C 值修改了，
这时候内存的值和 CPU 2 缓存中的 C 值就不等了，内存这时发现 C 值被 volatile 关键字修饰，
发现其是共享变量，就会使 CPU 2 缓存中的 C 值状态置为无效，CPU 2 会从内存中重新拉取最新的值，
这时候线程 2 再来读取 C 值时，读取的已经是内存中最新的值了。</p> <p><strong>5 transient</strong></p> <p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。
在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。</p> <p><strong>6 default</strong></p> <p>default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，
但自己必须有默认实现，我们举个例子如下：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/06.jpeg" alt="06">
default 关键字被很多源码使用，我们后面会说。</p> <p><strong>7 面试题</strong></p> <p><strong>7.1 如何证明 static 静态变量和类无关？</strong></p> <p>答：从三个方面就可以看出静态变量和类无关。</p> <ol><li>我们不需要初始化类就可直接使用静态变量；</li> <li>我们在类中写个 main 方法运行，即便不写初始化类的代码，静态变量都会自动初始化；</li> <li>静态变量只会初始化一次，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。<br>
不仅仅是静态变量，静态方法块也和类无关。</li></ol> <p><strong>7.2 常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？</strong>
答：这么做有两个目的：</p> <ol><li>变量和方法于类无关，可以直接使用，使用比较方便；</li> <li>强调变量内存地址不可变，方法不可继承覆写，强调了方法内部的稳定性。</li></ol> <p><strong>7.3 catch 中发生了未知异常，finally 还会执行么？</strong></p> <p>答：会的，catch 发生了异常，finally 还会执行的，并且是 finally 执行完成之后，才会抛出 catch 中的异常。</p> <p>不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。</p> <p><strong>7.4 volatile 关键字的作用和原理</strong></p> <p>答：这个上文说的比较清楚，可以参考上文。</p> <p><strong>总结</strong></p> <p>Java 的关键字属于比较基础的内容，我们需要清晰明确其含义，才能在后续源码阅读和工作中碰到这些关键字时了然于心，
才能明白为什么会在这里使用这样的关键字。比如 String 源码是如何使用 final 关键字达到起不变性的，
比如 Java 8 集合中 Map 是如何利用 default 关键字新增各种方法的，这些我们在后续内容都会提到。</p> <h3 id="_04-arrays、collections、objects-常用方法源码解析"><a href="#_04-arrays、collections、objects-常用方法源码解析" class="header-anchor">#</a> 04 Arrays、Collections、Objects 常用方法源码解析</h3> <p><strong>引导语</strong></p> <p>我们在工作中都会写工具类，但如何才能使写出来的工具类更好用，也是有一些技巧的。
本章内容以三种平时工作中经常使用的工具类为例，从使用案例出发，再看看底层源码的实现，
看看能否学习到一些工具类的技巧，以及三种工具类的实际使用场景。</p> <blockquote><p>下方是本专栏 GitHub 地址：
源码解析：https://github.com/luanqiu/java8
文章 demo：https://github.com/luanqiu/java8_demo
同学们有需要可以对照着来看 ：）</p></blockquote> <p><strong>1 工具类通用的特征</strong></p> <p>再看细节之前，我们先总结一下好的工具类都有哪些通用的特征写法：</p> <ol><li>构造器必须是私有的。这样的话，工具类就无法被 new 出来，因为工具类在使用的时候，
无需初始化，直接使用即可，所以不会开放出构造器出来。</li> <li>工具类的工具方法必须被 static、final 关键字修饰。这样的话就可以保证方法不可变，
并且可以直接使用，非常方便。</li></ol> <p>我们需要注意的是，尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），
因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用。</p> <p><strong>2 Arrays</strong></p> <p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。
我们选择其中两三看下，对其余操作感兴趣的同学可以到 GitHub 上查看源码解析。</p> <p><strong>2.1 排序</strong></p> <p>Arrays.sort 方法主要用于排序，入参支持 int、long、double 等各种基本类型的数组，
也支持自定义类的数组，下面我们写个 demo 来演示一下自定义类数组的排序：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token annotation punctuation">@Data</span>
   <span class="token comment">// 自定义类</span>
   <span class="token keyword">class</span> <span class="token class-name">SortDTO</span> <span class="token punctuation">{</span>
     <span class="token keyword">private</span> <span class="token class-name">String</span> sortTarget<span class="token punctuation">;</span>
   
     <span class="token keyword">public</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token class-name">String</span> sortTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>sortTarget <span class="token operator">=</span> sortTarget<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   
   <span class="token annotation punctuation">@Test</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SortDTO</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">ImmutableList</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
         <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
         <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">)</span>
     <span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 我们先把数组的大小初始化成 list 的大小，保证能够正确执行 toArray</span>
     <span class="token class-name">SortDTO</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
     list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;排序之前：{}&quot;</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">SortDTO</span><span class="token operator">::</span><span class="token function">getSortTarget</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;排序之后：{}&quot;</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   输出结果为：
   排序之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
   排序之后：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>从输出的结果中可以看到，排序之后的数组已经是有顺序的了，也可以看到 sort 方法支持两个入参：
要排序的数组和外部排序器。</p> <p>大家都说 sort 方法排序的性能较高，主要原因是 sort 使用了双轴快速排序算法，具体算法就不细说了。</p> <p><strong>2.1 二分查找法</strong></p> <p>Arrays.binarySearch 方法主要用于快速从数组中查找出对应的值。其支持的入参类型非常多，如 byte、int、long 各种类型的数组。
返回参数是查找到的对应数组下标的值，如果查询不到，则返回负数。</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/07.jpeg" alt="07"></p> <p>我们写了一个 demo 如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SortDTO</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">ImmutableList</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
       <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
       <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">)</span>
   <span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token class-name">SortDTO</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;搜索之前：{}&quot;</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">SortDTO</span><span class="token operator">::</span><span class="token function">getSortTarget</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;先排序，结果为：{}&quot;</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                       <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">SortDTO</span><span class="token operator">::</span><span class="token function">getSortTarget</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;没有找到 200&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;搜索结果：{}&quot;</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   输出的结果为：
   搜索之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
   先排序，结果为：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;220&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;300&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;50&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
   搜索结果：<span class="token punctuation">{</span><span class="token string">&quot;sortTarget&quot;</span><span class="token operator">:</span><span class="token string">&quot;200&quot;</span><span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>从上述代码中我们需要注意两点：</p> <ol><li>如果被搜索的数组是无序的，一定要先排序，否则二分搜索很有可能搜索不到，
我们 demo 里面也先对数组进行了排序；</li> <li>搜索方法返回的是数组的下标值。如果搜索不到，返回的下标值就会是负数，
这时我们需要判断一下正负。如果是负数，还从数组中获取数据的话，会报数组越界的错误。
demo 中对这种情况进行了判断，如果是负数，会提前抛出明确的异常。</li></ol> <p>接下来，我们来看下二分法底层代码的实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// a：我们要搜索的数组，fromIndex：从那里开始搜索，默认是0； toIndex：搜索到何时停止，默认是数组大小</span>
   <span class="token comment">// key：我们需要搜索的值 c：外部比较器</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">int</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span>
                                        <span class="token class-name">T</span> key<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果比较器 c 是空的，直接使用 key 的 Comparable.compareTo 方法进行排序</span>
       <span class="token comment">// 假设 key 类型是 String 类型，String 默认实现了 Comparable 接口，就可以直接使用 compareTo 方法进行排序</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 这是另外一个方法，使用内部排序器进行比较的方法</span>
           <span class="token keyword">return</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">int</span> low <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>
       <span class="token keyword">int</span> high <span class="token operator">=</span> toIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
       <span class="token comment">// 开始位置小于结束位置，就会一直循环搜索</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 假设 low =0，high =10，那么 mid 就是 5，所以说二分的意思主要在这里，每次都是计算索引的中间值</span>
           <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token class-name">T</span> midVal <span class="token operator">=</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
           <span class="token comment">// 比较数组中间值和给定的值的大小关系</span>
           <span class="token keyword">int</span> cmp <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>midVal<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">// 如果数组中间值小于给定的值，说明我们要找的值在中间值的右边</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token comment">// 我们要找的值在中间值的左边</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token keyword">else</span>
           <span class="token comment">// 找到了</span>
               <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment">// key found</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 返回的值是负数，表示没有找到</span>
       <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// key not found.</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>二分的主要意思是每次查找之前，都找到中间值，然后拿我们要比较的值和中间值比较，
根据结果修改比较的上限或者下限，通过循环最终找到相等的位置索引，以上代码实现比较简洁，
大家可以在自己理解的基础上，自己复写一遍。</p> <p><strong>2.2 拷贝</strong></p> <p>数组拷贝我们经常遇到，有时需要拷贝整个数组，有时需要拷贝部分，
比如 ArrayList 在 add（扩容） 或 remove（删除元素不是最后一个） 操作时，
会进行一些拷贝。拷贝整个数组我们可以使用 copyOf 方法，拷贝部分我们可以使用 copyOfRange 方法，
以 copyOfRange 为例，看下底层源码的实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// original 原始数组数据</span>
   <span class="token comment">// from 拷贝起点</span>
   <span class="token comment">// to 拷贝终点</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 需要拷贝的长度</span>
       <span class="token keyword">int</span> newLength <span class="token operator">=</span> <span class="token keyword">to</span> <span class="token operator">-</span> from<span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>newLength <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token string">&quot; &gt; &quot;</span> <span class="token operator">+</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 初始化新数组</span>
       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token comment">// 调用 native 方法进行拷贝，参数的意思分别是：</span>
       <span class="token comment">// 被拷贝的数组、从数组那里开始、目标数组、从目的数组那里开始拷贝、拷贝的长度</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                        <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length <span class="token operator">-</span> from<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> copy<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>从源码中，我们发现，Arrays 的拷贝方法，实际上底层调用的是 System.arraycopy 这个 native 方法，
如果你自己对底层拷贝方法比较熟悉的话，也可以直接使用。</p> <p><strong>3 Collections</strong></p> <p>Collections 是为了方便使用集合而产生的工具类，Arrays 方便数组使用，Collections 是方便集合使用。</p> <p>Collections 也提供了 sort 和 binarySearch 方法，sort 底层使用的就是 Arrays.sort 方法，
binarySearch 底层是自己重写了二分查找算法，实现的逻辑和 Arrays 的二分查找算法完全一致，
这两个方法上 Collections 和 Arrays 的内部实现很类似，接下来我们来看下 Collections 独有的特性。</p> <p><strong>3.1 求集合中最大、小值</strong></p> <p>提供了 max 方法来取得集合中的最大值，min 方法来取得集合中的最小值，max 和 min 方法很相似的，
我们以 max 方法为例来说明一下，max 提供了两种类型的方法，一个需要传外部排序器，
一个不需要传排序器，但需要集合中的元素强制实现 Comparable 接口，后者的泛型定义很有意思，
我们来看下（从右往左看）：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/08.jpeg" alt="08"></p> <p>从这段源码中，我们可以学习到两点：</p> <ol><li>max 方法泛型 T 定义得非常巧妙，意思是泛型必须继承 Object 并且实现 Comparable 的接口。
一般让我们来定义的话，我们可以会在方法里面去判断有无实现 Comparable 的接口，
这种是在运行时才能知道结果。而这里泛型直接定义了必须实现 Comparable 接口，
在编译的时候就可告诉使用者，当前类没有实现 Comparable 接口，使用起来很友好；</li> <li>给我们提供了实现两种排序机制的好示例：自定义类实现 Comparable 接口和传入外部排序器。
两种排序实现原理类似，但实现有所差别，我们在工作中如果需要些排序的工具类时，可以效仿。</li></ol> <p><strong>3.2 多种类型的集合</strong></p> <p>Collections 对原始集合类进行了封装，提供了更好的集合类给我们，一种是线程安全的集合，
一种是不可变的集合，针对 List、Map、Set 都有提供，我们先来看下线程安全的集合：</p> <p><strong>3.2.1 线程安全的集合</strong></p> <p>线程安全的集合方法都是 synchronized 打头的，如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/10.jpeg" alt="10">
从方法命名我们都可以看出来，底层是通过 synchronized 轻量锁来实现的，
我们以 synchronizedList 为例来说明下底层的实现：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/11.jpeg" alt="11">
可以看到 List 的所有操作方法都被加上了 synchronized 锁，所以多线程对集合同时进行操作，是线程安全的。</p> <p><strong>3.2.1 不可变的集合</strong></p> <p>得到不可变集合的方法都是以 unmodifiable 开头的。这类方法的意思是，我们会从原集合中，
得到一个不可变的新集合，新集合只能访问，无法修改；一旦修改，就会抛出异常。
这主要是因为只开放了查询方法，其余任何修改操作都会抛出异常，
我们以 unmodifiableList 为例来看下底层实现机制：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/12.jpeg" alt="12"></p> <p><strong>3.2.2 小结</strong></p> <p>以上两种 List 其实解决了工作中的一些困惑，比如说 ArrayList 是线程不安全的，
然后其内部数组很容易被修改，有的时候，我们希望 List 一旦生成后，就不能被修改，
Collections 对 List 重新进行了封装，提供了两种类型的集合封装形式，
从而解决了工作中的一些烦恼，如果你平时使用 List 时有一些烦恼，也可以学习此种方式，
自己对原始集合进行封装，来解决 List 使用过程中的不方便。</p> <p><strong>4 Objects</strong></p> <p>对于 Objects，我们经常使用的就是两个场景，相等判断和判空。</p> <p><strong>4.1 相等判断</strong></p> <p>Objects 有提供 equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，
后者是用来判断数组的，我们来看下底层的源码实现：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/13.jpeg" alt="13">
从源码中，可以看出 Objects 对基本类型和复杂类型的对象，都有着比较细粒度的判断，可以放心使用。</p> <p><strong>4.2 为空判断</strong> <img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/01%E5%9F%BA%E7%A1%80/14.jpeg" alt="14">
Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值，
requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常，我们需要根据生活的场景选择使用。</p> <p><strong>5 面试题</strong></p> <p><strong>5.1 工作中有没有遇到特别好用的工具类，如何写好一个工具类</strong></p> <p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、
Objects 的判空相等判断等等工具类，好的工具类肯定很好用，
比如说使用 static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段来写好工具类。</p> <p><strong>5.2 写一个二分查找算法的实现</strong></p> <p>答：可以参考 Arrays 的 binarySearch 方法的源码实现。</p> <p><strong>5.3 如果我希望 ArrayList 初始化之后，不能被修改，该怎么办</strong></p> <p>答：可以使用 Collections 的 unmodifiableList 的方法，该方法会返回一个不能被修改的内部类集合，
这些集合类只开放查询的方法，对于调用修改集合的方法会直接抛出异常。</p> <p><strong>总结</strong></p> <p>从三大工具类中，我们不仅学习到了如何写好一个工具类，还熟悉了三大工具类的具体使用姿势，
甚至了解了其底层的源码实现，有兴趣的话，可以自己也可以仿照写个好用的工具类加深学习。</p> <h2 id="第2章-集合"><a href="#第2章-集合" class="header-anchor">#</a> 第2章 集合</h2> <h3 id="_05-arraylist-源码解析和设计思路"><a href="#_05-arraylist-源码解析和设计思路" class="header-anchor">#</a> 05 ArrayList 源码解析和设计思路</h3> <p><strong>引导语</strong></p> <p>ArrayList 我们几乎每天都会使用到，但真正面试的时候，发现还是有不少人对源码细节说不清楚，
给面试官留下比较差的印象，本小节就和大家一起看看面试中和 ArrayList 相关的源码。</p> <p><strong>1 整体架构</strong></p> <p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/01.jpeg" alt="01">
图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，
从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p> <ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li> <li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li> <li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li></ul> <p><strong>类注释</strong></p> <p>看源码，首先要看类注释，我们看看类注释上面都说了什么，如下：</p> <ul><li>允许 put null 值，会自动扩容；</li> <li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li> <li>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；</li> <li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li></ul> <p>除了上述注释中提到的 4 点，初始化、扩容的本质、迭代器等问题也经常被问，接下来我们从源码出发，
一一解析。</p> <p><strong>2 源码解析</strong></p> <p><strong>2.1 初始化</strong></p> <p>我们有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   
   <span class="token comment">//无参数直接初始化，数组大小为空</span>
   <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">//指定初始数据初始化</span>
   <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//elementData 是保存数组的容器，默认为 null</span>
       elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">//如果给定的集合（c）数据有值</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
           <span class="token comment">//如果集合元素类型不是 Object 类型，我们会转成 Object</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// 给定集合（c）无值，则默认空数组</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>除了源码的中文注释，我们补充两点：</p> <p>1：ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，
10 是在第一次 add 的时候扩容的数组值。</p> <p>2：指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，
意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。一般情况下都不会触发此 bug，只有在下列场景下才会触发：ArrayList 初始化之后（ArrayList 元素非 Object 类型），再次调用 toArray 方法，得到 Object 数组，并且往 Object 数组赋值时，才会触发此 bug，代码和原因如图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/02.jpeg" alt="02">
官方查看文档地址：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652" target="_blank" rel="noopener noreferrer">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，问题在 Java 9 中被解决。</p> <p><strong>2.2 新增和扩容实现</strong></p> <p>新增就是往数组中添加元素，主要分成两步：</p> <ul><li>判断是否需要扩容，如果需要执行扩容操作；</li> <li>直接赋值。</li></ul> <p>两步源码体现如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>
     <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>
     <span class="token comment">//直接赋值，线程不安全的</span>
     elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>我们先看下扩容（ensureCapacityInternal）的源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">//确保容积足够</span>
     <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//记录数组被修改</span>
     modCount<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">//扩容，并把现有数据拷贝到新的数组里面去</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
     <span class="token comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span>
     <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>
   
     <span class="token comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
     <span class="token comment">// 通过复制进行扩容</span>
     elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>注解应该比较详细，我们需要注意的四点是：</p> <ul><li><p>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</p></li> <li><p>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</p></li> <li><p>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</p></li> <li><p>从新增和扩容源码中，下面这点值得我们借鉴：</p></li></ul> <p>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，
上界不能大于 Integer 的最大值，这种意识我们可以学习。
扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。
也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的，对于新增和扩容的实现，
画了一个动图，如下：
<img src="https://img1.sycdn.imooc.com/5d5fc62e000112c203600240.gif" alt="03"></p> <p><strong>2.3 扩容的本质</strong></p> <p>扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，
这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，
然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，
此方法是 native 的方法，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">/**
    * @param src     被拷贝的数组
    * @param srcPos  从数组那里开始
    * @param dest    目标数组
    * @param destPos 从目标数组那个索引位置开始拷贝
    * @param length  拷贝的长度 
    * 此方法是没有返回值的，通过 dest 的引用进行传值
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span>
                                       <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>
                                       <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们可以通过下面这行代码进行调用，newElementData 表示新的数组：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>elementData<span class="token punctuation">.</span>length<span class="token punctuation">,</span>newCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p><strong>2.4 删除</strong></p> <p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，
原理和思路都差不多，我们选取根据值删除方式来进行源码说明：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果要删除的值是 null，找到第一个值是 null 的删除</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
         <span class="token comment">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>我们需要注意的两点是：</p> <ul><li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li> <li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。
上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 记录数组的结构要发生变动了</span>
     modCount<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token comment">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span>
     <span class="token comment">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span>
     <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token comment">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//数组最后一个位置赋值 null，帮助 GC</span>
     elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，
下面动图也演示了其过程：</p> <p><img src="https://img1.sycdn.imooc.com/5d5fc643000142a403600240.gif" alt="04"></p> <p><strong>2.5 迭代器</strong></p> <p>如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，
我们来看下迭代器的几个总要的参数：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">int</span> cursor<span class="token punctuation">;</span><span class="token comment">// 迭代过程中，下一个元素的位置，默认从 0 开始。</span>
   <span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 新增场景：表示上一次迭代过程中，索引的位置；删除场景：为 -1。</span>
   <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span><span class="token comment">// expectedModCount 表示迭代过程中，</span>
   期望的版本号；modCount 表示数组实际的版本号。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>迭代器一般来说有三个方法：</p> <ul><li>hasNext 还有没有值可以迭代</li> <li>next 如果有值可以迭代，迭代的值是多少</li> <li>remove 删除当前迭代的值</li></ul> <p>我们来分别看下三个方法的源码：</p> <p><strong>hasNext</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span><span class="token comment">//cursor 表示下一个元素的位置，size 表示实际大小，如果两者相等，说明已经没有元素可以迭代了，如果不等，说明还可以迭代</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>next</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>
     <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//本次迭代过程中，元素的索引位置</span>
     <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 下一次迭代时，元素的位置，为下一次迭代做准备</span>
     cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
     <span class="token comment">// 返回元素值</span>
     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 版本号比较</span>
   <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>从源码中可以看到，next 方法就干了两件事情，第一是检验能不能继续迭代，第二是找到迭代的值，
并为下一次迭代做准备（cursor+1）。</p> <p><strong>remove</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>
     <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
       <span class="token class-name">ArrayList</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>
       cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>
       <span class="token comment">// -1 表示元素已经被删除，这里也防止重复删除</span>
       lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
       <span class="token comment">// 删除元素时 modCount 的值已经发生变化，在此赋值给 expectedModCount</span>
       <span class="token comment">// 这样下次迭代时，两者的值是一致的了</span>
       expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这里我们需要注意的两点是：</p> <ul><li>lastRet = -1 的操作目的，是防止重复删除操作</li> <li>删除元素成功，数组当前 modCount 就会发生变化，这里会把 expectedModCount 重新赋值，
下次迭代时两者的值就会一致了</li></ul> <p><strong>2.6 时间复杂度</strong></p> <p>从我们上面新增或删除方法的源码解析，对数组元素的操作，只需要根据数组索引，直接新增和删除，
所以时间复杂度是 O (1)。</p> <p><strong>2.7 线程安全</strong></p> <p>我们需要强调的是，只有当 ArrayList 作为共享变量时，才会有线程安全问题，
当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。</p> <p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut
在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，
所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p> <p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，
SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，
但是性能大大降低，具体实现源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span>
           <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>总结</strong></p> <p>本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，
我们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，
让使用者无需感知底层实现，只需关注如何使用即可。</p> <h3 id="_06-linkedlist-源码解析"><a href="#_06-linkedlist-源码解析" class="header-anchor">#</a> 06 LinkedList 源码解析</h3> <p><strong>引导语</strong></p> <p>LinkedList 适用于集合元素先入先出和先入后出的场景，在队列源码中被频繁使用，
面试也经常问到，本小节让我们通过源码来加深对 LinkedList 的了解。</p> <p><strong>1 整体架构</strong></p> <p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/05.jpeg" alt="05"></p> <p>上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p> <ul><li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，
代表后一个节点的位置；</li> <li>first 是双向链表的头节点，它的前一个节点是 null。</li> <li>last 是双向链表的尾节点，它的后一个节点是 null；</li> <li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li> <li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li></ul> <p>链表中的元素叫做 Node，我们看下 Node 的组成部分：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token class-name">E</span> item<span class="token punctuation">;</span><span class="token comment">// 节点值</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span> <span class="token comment">// 指向的下一个节点</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">;</span> <span class="token comment">// 指向的前一个节点</span>
   
       <span class="token comment">// 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点</span>
       <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> prev<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>2 源码解析</strong></p> <p><strong>2.1 追加（新增）</strong></p> <p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，
addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p> <p><strong>从尾部追加（add）</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 从尾部开始追加节点</span>
   <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 把尾节点数据暂存</span>
       <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
       <span class="token comment">// 新建新的节点，初始化入参含义：</span>
       <span class="token comment">// l 是新节点的前一个节点，当前值是尾节点值</span>
       <span class="token comment">// e 表示当前新增节点，当前新增节点后一个节点是 null</span>
       <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 新建节点追加到尾部</span>
       last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       <span class="token comment">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token operator">!</span><span class="token punctuation">[</span>图片描述<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token comment">//img1.sycdn.imooc.com/5d5fc69600013e4803600240.gif)</span>
       <span class="token comment">//否则把前尾节点的下一个节点，指向当前尾节点。</span>
       <span class="token keyword">else</span>
           l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       <span class="token comment">//大小和版本更改</span>
       size<span class="token operator">++</span><span class="token punctuation">;</span>
       modCount<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可，
我们做个动图来描述下整个过程：</p> <p><img src="https://img1.sycdn.imooc.com/5d5fc6a300013e4803600240.gif" alt="06"></p> <p><strong>从头部追加（addFirst）</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 从头部追加</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 头节点赋值给临时变量</span>
       <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>
       <span class="token comment">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span>
       <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 新建节点成为头节点</span>
       first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       <span class="token comment">// 头节点为空，就是链表为空，头尾节点是一个节点</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       <span class="token comment">//上一个头节点的前一个节点指向当前节点</span>
       <span class="token keyword">else</span>
           f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
       size<span class="token operator">++</span><span class="token punctuation">;</span>
       modCount<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，
后者是移动尾节点的 next 指向。</p> <p><strong>2.2 节点删除</strong></p> <p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，
删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p> <p><strong>从头部删除</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//从头删除节点 f 是链表头节点</span>
   <span class="token keyword">private</span> <span class="token class-name">E</span> <span class="token function">unlinkFirst</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 拿出头节点的值，作为方法的返回值</span>
       <span class="token keyword">final</span> <span class="token class-name">E</span> element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
       <span class="token comment">// 拿出头节点的下一个节点</span>
       <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
       <span class="token comment">//帮助 GC 回收头节点</span>
       f<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       f<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       <span class="token comment">// 头节点的下一个节点成为头节点</span>
       first <span class="token operator">=</span> next<span class="token punctuation">;</span>
       <span class="token comment">//如果 next 为空，表明链表为空</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       <span class="token comment">//链表不为空，头节点的前一个节点指向 null</span>
       <span class="token keyword">else</span>
           next<span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       <span class="token comment">//修改链表大小和版本</span>
       size<span class="token operator">--</span><span class="token punctuation">;</span>
       modCount<span class="token operator">++</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> element<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>从尾部删除节点代码也是类似的，就不贴了。</p> <p><strong>从源码中我们可以了解到，链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，
所以 LinkedList 新增和删除速度很快。</strong></p> <p><strong>2.3 节点查询</strong></p> <p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，
我们看看 LinkedList 的源码是如何寻找节点的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 根据链表索引位置查询节点</span>
   <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果 index 处于队列的前半部分，从头开始找，size &gt;&gt; 1 是 size 除以 2 的意思。</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
           <span class="token comment">// 直到 for 循环到 index 的前一个 node 停止</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
               x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
           <span class="token keyword">return</span> x<span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">// 如果 index 处于队列的后半部分，从尾开始找</span>
           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
           <span class="token comment">// 直到 for 循环到 index 的后一个 node 停止</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
               x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
           <span class="token keyword">return</span> x<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，
首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。
通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p> <p><strong>2.4 方法对比</strong></p> <p>LinkedList 实现了 Queue 接口，在新增、删除、查询等方面增加了很多新的方法，
这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样，我们列一个表格，方便大家记录：</p> <table><thead><tr><th style="text-align:center;">方法含义</th> <th style="text-align:center;">返回异常</th> <th style="text-align:center;">返回特殊值</th> <th style="text-align:center;">底层实现</th></tr></thead> <tbody><tr><td style="text-align:center;">新增</td> <td style="text-align:center;">add(e)</td> <td style="text-align:center;">offer(e)</td> <td style="text-align:center;">底层实现相同</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">remove()</td> <td style="text-align:center;">poll(e)</td> <td style="text-align:center;">链表为空时，remove 会抛出异常，poll 返回 null。</td></tr> <tr><td style="text-align:center;">查找</td> <td style="text-align:center;"></td> <td style="text-align:center;">element()</td> <td style="text-align:center;">peek()</td></tr></tbody></table> <p>PS：Queue 接口注释建议 add 方法操作失败时抛出异常，但 LinkedList 实现的 add 方法一直返回 true。
LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。</p> <p><strong>2.5 迭代器</strong></p> <p>因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，
因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做：ListIterator，
这个接口提供了向前和向后的迭代方法，如下所示：</p> <table><thead><tr><th style="text-align:center;">迭代顺序</th> <th style="text-align:center;">方法</th></tr></thead> <tbody><tr><td style="text-align:center;">从尾到头迭代方法</td> <td style="text-align:center;">hasPrevious、previous、previousIndex</td></tr> <tr><td style="text-align:center;">从头到尾迭代方法</td> <td style="text-align:center;">hasNext、next、nextIndex</td></tr></tbody></table> <p>LinkedList 实现了 ListIterator 接口，如下图所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 双向迭代器</span>
   <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastReturned<span class="token punctuation">;</span><span class="token comment">//上一次执行 next() 或者 previos() 方法时的节点位置</span>
       <span class="token keyword">private</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span><span class="token comment">//下一个节点</span>
       <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span><span class="token comment">//下一个节点的位置</span>
       <span class="token comment">//expectedModCount：期望版本号；modCount：目前最新版本号</span>
       <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
       …………
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>我们先来看下从头到尾方向的迭代：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 判断还有没有下一个元素</span>
   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span><span class="token comment">// 下一个节点的索引小于链表的大小，就有</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 取下一个元素</span>
   <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//检查期望版本号有无发生变化</span>
       <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//再次检查</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// next 是当前节点，在上一次执行 next() 方法时被赋值的。</span>
       <span class="token comment">// 第一次执行时，是在初始化迭代器的时候，next 被赋值的</span>
       lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>
       <span class="token comment">// next 是下一个节点了，为下次迭代做准备</span>
       next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
       nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>上述源码的思路就是直接取当前节点的下一个节点，而从尾到头迭代稍微复杂一点，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span>
   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> nextIndex <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 取前一个节点</span>
   <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// next 为空场景：1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了</span>
       <span class="token comment">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span>
       lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
       <span class="token comment">// 索引位置变化</span>
       nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>这里复杂点体现在需要判断 next 不为空和为空的场景，代码注释中有详细的描述。</p> <p><strong>迭代器删除</strong></p> <p>LinkedList 在删除元素时，也推荐通过迭代器进行删除，删除过程如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：</span>
       <span class="token comment">// lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错</span>
       <span class="token comment">// lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
       <span class="token comment">//删除当前节点</span>
       <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span>
       <span class="token comment">// 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>
           <span class="token comment">// 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next</span>
           next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>
       <span class="token keyword">else</span>
           nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
       lastReturned <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>总结</strong></p> <p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，主要是依赖于底层的链表结构，
在面试中的频率还是蛮高的，相信理清楚上面的源码后，应对面试应该没有问题。</p> <h3 id="_07-list-源码会问哪些面试题"><a href="#_07-list-源码会问哪些面试题" class="header-anchor">#</a> 07 List 源码会问哪些面试题</h3> <p><strong>引导语</strong></p> <p>List 作为工作中最常见的集合类型，在面试过程中，也是经常会被问到各种各样的面试题，
一般来说，只要你看过源码，心中对 List 的总体结构和细节有所了解的话，基本问题都不大。</p> <p><strong>1 面试题</strong></p> <p><strong>1.1 说说你自己对 ArrayList 的理解？</strong></p> <p>很多面试官喜欢这样子开头，考察面试同学对 ArrayList 有没有总结经验，介于 ArrayList 内容很多，
建议先回答总体架构，再从某个细节出发作为突破口，比如这样：
ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，
比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p> <p>一般面试官看你回答得井井有条，并且没啥漏洞的话，基本就不会深究了，
这样面试的主动权就掌握在自己手里面了，如果你回答得支支吾吾，
那么面试官可能就会开启自己面试的套路了。</p> <p>说说你自己对 LinkedList 的理解也是同样套路。</p> <p><strong>1.2 扩容类问题</strong></p> <p><strong>1.2.1 ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</strong></p> <p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，
是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p> <p><strong>1.2.2 如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</strong></p> <p>答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，
但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，
oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，
然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p> <p><strong>1.2.3 数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</strong></p> <p>答：第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，
现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，
明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，
这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span>
   <span class="token comment">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>所以最终数组扩容后的大小为 16。</p> <p><strong>1.2.4 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</strong></p> <p>答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，
频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，
指定新数组的大小为 5k 即可。</p> <p><strong>1.2.5 为什么说扩容会消耗性能？</strong></p> <p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，
所以性能消耗比较严重。</p> <p><strong>1.2.6 源码扩容过程有什么值得借鉴的地方？</strong></p> <p>答：有两点：</p> <ul><li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，
1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，
大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，
也可快速扩容。</li> <li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，
不能大于 Integer 的最大值。
这两点在我们平时设计和写代码时都可以借鉴。</li></ul> <p><strong>2 删除类问题</strong></p> <p><strong>2.1 有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，
现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，
请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/06.jpeg" alt="06"></p> <p>从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p> <p><strong>2.2 还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？</strong></p> <p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，
当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，
而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，
expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p> <p><strong>2.3 还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？</strong></p> <p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount
赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p> <p><strong>2.4 以上三个问题对于 LinkedList 也是同样的结果么？</strong></p> <p>答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p> <p><strong>3 对比类问题</strong></p> <p><strong>3.1 ArrayList 和 LinkedList 有何不同？</strong></p> <p>答：可以先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p> <p><strong>3.2 ArrayList 和 LinkedList 应用场景有何不同</strong></p> <p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p> <p><strong>3.3 ArrayList 和 LinkedList 两者有没有最大容量</strong></p> <p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p> <p><strong>3.4 ArrayList 和 LinkedList 是如何对 null 值进行处理的</strong></p> <p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p> <p><strong>3.5 ArrayList 和 LinedList 是线程安全的么，为什么？</strong></p> <p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p> <p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p> <p><strong>3.6 如何解决线程安全问题？</strong></p> <p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用 CopyOnWriteArrayList 并发 List 来解决，这个类我们后面会说。</p> <p><strong>4 其它类型题目</strong></p> <p><strong>4.1 你能描述下双向链表么？</strong></p> <p>答：如果和面试官面对面沟通的话，你可以去画一下，可以把 《LinkedList 源码解析》中的 LinkedList 的结构画出来，如果是电话面试，可以这么描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p> <p><strong>4.2 描述下双向链表的新增和删除</strong></p> <p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p> <p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p> <p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p> <p><strong>总结</strong></p> <p>List 在工作中经常遇到，熟读源码不仅仅是为了应对面试，也为了在工作中使用起来得心应手，如果想更深入了解 List，可以看一遍 ArrayList 源码之后，自己重新实现一个 List。这样的话，就会对 List 底层的数据结构和操作细节理解更深。</p> <h3 id="_08-hashmap-源码解析"><a href="#_08-hashmap-源码解析" class="header-anchor">#</a> 08 HashMap 源码解析</h3> <p><strong>引导语</strong></p> <p>HashMap 源码很长，面试的问题也非常多，但这些面试问题，基本都是从源码中衍生出来的，
所以我们只需要弄清楚其底层实现原理，回答这些问题就会游刃有余。</p> <p><strong>1 整体架构</strong></p> <p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，
链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/07.jpeg" alt="07"></p> <p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树，具体细节我们下文再说。</p> <p>1.1 类注释
从 HashMap 的类注释中，我们可以得到如下信息：</p> <ul><li>允许 null 值，不同于 HashTable ，是线程不安全的；</li> <li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li> <li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li> <li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li> <li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul> <p><strong>1.2 常见属性</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//初始容量为 16</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
   
    <span class="token comment">//最大容量</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>
   
    <span class="token comment">//负载因子默认值</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>
    
    <span class="token comment">//桶上的链表长度大于等于8时，链表转化成红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
   
    <span class="token comment">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
   
    <span class="token comment">//当数组容量大于 64 时，链表才会转化成红黑树</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
   
    <span class="token comment">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>
   
    <span class="token comment">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span>
    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>
   
    <span class="token comment">//存放数据的数组</span>
    <span class="token keyword">transient</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>
   
    <span class="token comment">// 扩容的门槛，有两种情况</span>
    <span class="token comment">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span>
    <span class="token comment">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span>
    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>
   
    <span class="token comment">//链表的节点</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    
    <span class="token comment">//红黑树的节点</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p><strong>2 新增</strong></p> <p>新增 key，value 大概的步骤如下：</p> <ol><li>空数组有无初始化，没有的话初始化；</li> <li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li> <li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li> <li>如果是链表，递归循环，把新元素追加到队尾；</li> <li>如果是红黑树，调用红黑树新增的方法；</li> <li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li> <li>判断是否需要扩容，需要扩容进行扩容，结束。</li> <li>我们来画一张示意图来描述下：</li></ol> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/08.jpg" alt="08"></p> <p>代码细节如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 入参 hash：通过 hash 算法计算出来的值。</span>
   <span class="token comment">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span>
   <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
                  <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
       <span class="token comment">//如果数组为空，使用 resize 方法初始化</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
           n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
       <span class="token comment">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span>
       <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// e 当前节点的临时变量</span>
           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
           <span class="token comment">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
               <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
               e <span class="token operator">=</span> p<span class="token punctuation">;</span>
           <span class="token comment">// 如果是红黑树，使用红黑树的方式新增</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
               e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">// 是个链表，把新节点放到链表的尾端</span>
           <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token comment">// 自旋</span>
               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token comment">// e = p.next 表示从头开始，遍历链表</span>
                   <span class="token comment">// p.next == null 表明 p 是链表的尾节点</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">// 把新节点放到链表的尾部 </span>
                       p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token comment">// 当链表的长度大于等于 8 时，链表转红黑树</span>
                       <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                           <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token keyword">break</span><span class="token punctuation">;</span>
                   <span class="token punctuation">}</span>
                   <span class="token comment">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                       <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                       <span class="token keyword">break</span><span class="token punctuation">;</span>
                   <span class="token comment">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span>
                   p <span class="token operator">=</span> e<span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token comment">// 说明新节点的新增位置已经找到了</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
               <span class="token comment">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                   e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
               <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token comment">// 返回老值</span>
               <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 记录 HashMap 的数据结构发生了变化</span>
       <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
       <span class="token comment">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
           <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br></div></div><p>新增的流程上面应该已经表示很清楚了，接下来我们来看看链表和红黑树新增的细节：</p> <p>2.1 链表的新增
链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p> <p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，
此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，
当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，
具体转化的过程源码可以去 <a href="github%EF%BC%9Ahttps://github.com/luanqiu/java8">github：https://github.com/luanqiu/java8</a> 上面去查看。</p> <p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p> <p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，
使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，
但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p> <p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，
链表各个长度的命中概率为：</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code>   * 0:    0.60653066
   * 1:    0.30326533
   * 2:    0.07581633
   * 3:    0.01263606
   * 4:    0.00157952
   * 5:    0.00015795
   * 6:    0.00001316
   * 7:    0.00000094
   * 8:    0.00000006
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p> <p><strong>2.2 红黑树新增节点过程</strong></p> <ol><li>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</li></ol> <p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p> <p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p> <ol start="2"><li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p></li> <li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p></li> <li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p></li> <li><p>进行着色和旋转，结束。</p></li></ol> <p>具体源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//入参 h：key 的hash值</span>
   <span class="token keyword">final</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>
                                  <span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token class-name">K</span> k<span class="token punctuation">,</span> <span class="token class-name">V</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> kc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
       <span class="token comment">//找到根节点</span>
       <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
       <span class="token comment">//自旋</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span> <span class="token class-name">K</span> pk<span class="token punctuation">;</span>
           <span class="token comment">// p hash 值大于 h，说明 p 在 h 的右边</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">&gt;</span> h<span class="token punctuation">)</span>
               dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token comment">// p hash 值小于 h，说明 p 在 h 的左边</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
               dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token comment">//要放进去key在当前树中已经存在了(equals来判断)</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token keyword">return</span> p<span class="token punctuation">;</span>
           <span class="token comment">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                     <span class="token comment">//得到key的Class类型，如果key没有实现Comparable就是null</span>
                     <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                     <span class="token comment">//当前节点pk和入参k不等</span>
                    <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>
                   searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                       <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                       <span class="token keyword">return</span> q<span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
   
           <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>
           <span class="token comment">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
               <span class="token comment">//生成新的节点</span>
               <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token comment">//把新节点放在当前子节点为空的位置上</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                   xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
               <span class="token keyword">else</span>
                   xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
               <span class="token comment">//当前节点和新节点建立父子，前后关系</span>
               xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>
               x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>
               <span class="token comment">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span>
               <span class="token comment">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span>
               <span class="token comment">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span>
               <span class="token comment">//如果当前节点是父亲的右节点，则进行左旋</span>
               <span class="token comment">//如果当前节点是父亲的左节点，则进行右旋</span>
             
               <span class="token comment">//moveRootToFront 方法是把算出来的root放到根节点上</span>
               <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p> <ol><li>节点是红色或黑色</li> <li>根是黑色</li> <li>所有叶子都是黑色</li> <li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li> <li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li></ol> <p><strong>3 查找</strong></p> <p>HashMap 的查找主要分为以下三步：</p> <ul><li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li> <li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li> <li>分别走链表和红黑树不同类型的查找方法。
链表查找的关键代码是：</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token operator">/</span> 采用自旋方式从链表中查找 key，e 初始为为链表的头节点
   <span class="token keyword">do</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点</span>
       <span class="token comment">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
           <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> e<span class="token punctuation">;</span>
       <span class="token comment">// 否则，把当前节点的下一个节点拿出来继续寻找</span>
   <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>红黑树查找的代码很多，我们大概说下思路，实际步骤比较复杂，可以去 github 上面去查看源码：</p> <ol><li>从根节点递归查找；</li> <li>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；</li> <li>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</li> <li>一直自旋到定位到节点位置为止。</li></ol> <p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p> <p><strong>总结</strong></p> <p>HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封装而已，
本小节我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表和红黑树进行操作的。
想了解更多，可以前往 github 上查看更多源码。</p> <h3 id="_09-treemap-和-linkedhashmap-核心源码解析"><a href="#_09-treemap-和-linkedhashmap-核心源码解析" class="header-anchor">#</a> 09 TreeMap 和 LinkedHashMap 核心源码解析</h3> <p><strong>引导语</strong></p> <p>在熟悉 HashMap 之后，本小节我们来看下 TreeMap 和 LinkedHashMap，
看看 TreeMap 是如何根据 key 进行排序的，LinkedHashMap 是如何用两种策略进行访问的。</p> <p><strong>1 知识储备</strong></p> <p>在了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备，
两种方式的代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeMapDemo</span> <span class="token punctuation">{</span>
   
     <span class="token annotation punctuation">@Data</span>
     <span class="token comment">// DTO 为我们排序的对象</span>
     <span class="token keyword">class</span> DTO <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span>DTO<span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token function">DTO</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   
       <span class="token annotation punctuation">@Override</span>
       <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">DTO</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//默认从小到大排序</span>
         <span class="token keyword">return</span> id <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   
     <span class="token annotation punctuation">@Test</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTwoComparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序</span>
       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>DTO<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
       <span class="token comment">// 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序</span>
       <span class="token class-name">Comparator</span> comparator <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span>DTO<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> o2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span>DTO<span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>第一种排序输出的结果从小到大，结果是：[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]；</p> <p>第二种输出的结果恰好相反，结果是：[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]。</p> <p>以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，
而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。</p> <p><strong>2 TreeMap 整体架构</strong></p> <p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p> <p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，
使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p> <p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove
等方法的时间复杂度都是 log(n)。</p> <p><strong>2.1 属性</strong></p> <p>TreeMap 常见的属性有：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span>
   <span class="token comment">//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法</span>
   <span class="token comment">//比较手段和上面日常工作中的比较 demo 是一致的</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> comparator<span class="token punctuation">;</span>
   
   <span class="token comment">//红黑树的根节点</span>
   <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> root<span class="token punctuation">;</span>
   
   <span class="token comment">//红黑树的已有元素大小</span>
   <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   
   <span class="token comment">//树结构变化的版本号，用于迭代过程中的快速失败场景</span>
   <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   
   <span class="token comment">//红黑树的节点</span>
   <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><strong>2.2 新增节点</strong></p> <p>我们来看下 TreeMap 新增节点的步骤：</p> <ol><li>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点，代码如下：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span>
   <span class="token comment">//红黑树根节点为空，直接新建</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// compare 方法限制了 key 不能为 null</span>
       <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// type (and possibly null) check</span>
       <span class="token comment">// 成为根节点</span>
       root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
       modCount<span class="token operator">++</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><ol start="2"><li>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点，代码如下：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">K</span><span class="token punctuation">&gt;</span></span> cpr <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上</span>
       <span class="token keyword">do</span> <span class="token punctuation">{</span>
           <span class="token comment">//一次循环结束时，parent 就是上次比过的对象</span>
           parent <span class="token operator">=</span> t<span class="token punctuation">;</span>
           <span class="token comment">// 通过 compare 来比较 key 的大小</span>
           cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">//key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
           <span class="token comment">//key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
           <span class="token comment">//如果相等的话，直接覆盖原值</span>
           <span class="token keyword">else</span>
               <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">// t 为空，说明已经到叶子节点了</span>
       <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><ol start="3"><li>在父节点的左边或右边插入新增节点，代码如下：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
       parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span>
   <span class="token comment">//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。</span>
   <span class="token keyword">else</span>
       parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ol start="4"><li>着色旋转，达到平衡，结束。</li></ol> <p>从源码中，我们可以看到：</p> <p>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，
节点为 null 说明到达了叶子结点；
查找过程中，发现 key 值已经存在，直接覆盖；
TreeMap 是禁止 key 是 null 值的。
类似的，TreeMap 查找也是类似的原理，有兴趣的同学可以去 github 上面去查看源码。</p> <p><strong>2.3 小结</strong></p> <p>TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare
来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key
的大小排序顺序。</p> <p><strong>3 LinkedHashMap 整体架构</strong></p> <p>HashMap 是无序的，TreeMap 可以按照 key 进行排序，那有木有 Map 是可以维护插入的顺序的呢？
接下来我们一起来看下 LinkedHashMap。</p> <p>LinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，
还提供了两大特性：</p> <p>按照插入顺序进行访问；
实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。
接着我们来看下上述两大特性。</p> <p><strong>3.1 按照插入顺序访问</strong></p> <p><strong>3.1.1 LinkedHashMap 链表结构</strong></p> <p>我们看下 LinkedHashMap 新增了哪些属性，以达到了链表结构的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 链表头</span>
   <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> head<span class="token punctuation">;</span>
   
   <span class="token comment">// 链表尾</span>
   <span class="token keyword">transient</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> tail<span class="token punctuation">;</span>
   
   <span class="token comment">// 继承 Node，为数组的每个元素增加了 before 和 after 属性</span>
   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap</span><span class="token punctuation">.</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
       <span class="token class-name">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 控制两种访问模式的字段，默认 false</span>
   <span class="token comment">// true 按照访问顺序，会把经常访问的 key 放到队尾</span>
   <span class="token comment">// false 按照插入顺序提供访问</span>
   <span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>从上述 Map 新增的属性可以看到，LinkedHashMap 的数据结构很像是把
LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，
也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，
就可以维护元素插入进来的顺序。</p> <p><strong>3.1.2 如何按照顺序新增</strong></p> <p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，
插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的
newNode/newTreeNode 和 afterNodeAccess 方法。</p> <p>newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，
即可保证插入顺序了，我们以 newNode 源码为例：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 新增节点，并追加到链表的尾部</span>
   <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 新增节点</span>
       <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span>
           <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 追加到链表的尾部</span>
       <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> p<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// link at the end of list</span>
   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span><span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>
       <span class="token comment">// 新增节点等于位节点</span>
       tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
       <span class="token comment">// last 为空，说明链表为空，首尾节点相等</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           head <span class="token operator">=</span> p<span class="token punctuation">;</span>
       <span class="token comment">// 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可</span>
       <span class="token keyword">else</span> <span class="token punctuation">{</span>
           p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
           last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，
都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p> <p><strong>3.1.3 按照顺序访问</strong></p> <p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，
不能像 LinkedList 那样可以双向访问。</p> <p>我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，
不断访问当前节点的 after 节点即可。</p> <p>Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，
就可使用 <code>LinkedHashMap.entrySet().iterator()</code> 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，
我们调用迭代器的 nextNode 方法就可以得到下一个节点，迭代器的源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 初始化时，默认从头节点开始访问</span>
   <span class="token class-name">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 头节点作为第一个访问的节点</span>
       next <span class="token operator">=</span> head<span class="token punctuation">;</span>
       expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
       current <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   
   <span class="token keyword">final</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span><span class="token comment">// 校验</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       current <span class="token operator">=</span> e<span class="token punctuation">;</span>
       next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span> <span class="token comment">// 通过链表的 after 结构，找到下一个迭代的节点</span>
       <span class="token keyword">return</span> e<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。</p> <p><strong>3.2 访问最少删除策略</strong></p> <p><strong>3.2.1 demo</strong></p> <p>这种策略也叫做 LRU（Least recently used,最近最少使用），
大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，
然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除，
我们写个 demo 方便大家理解。demo 如下，完整代码可到 github 上查看：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAccessOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 新建 LinkedHashMap</span>
     <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0.75f</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">{</span>
         <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   
       <span class="token annotation punctuation">@Override</span>
       <span class="token comment">// 覆写了删除策略的方法，我们设定当节点个数大于 3 时，就开始删除头节点</span>
       <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">;</span>
   
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;初始化：{}&quot;</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;map.get(9)：{}&quot;</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;map.get(20)：{}&quot;</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>打印出来的结果如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   初始化：<span class="token punctuation">{</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span>
   map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">}</span>
   map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到，map 初始化的时候，我们放进去四个元素，但结果只有三个元素，10 不见了，
这个主要是因为我们覆写了 removeEldestEntry 方法，我们实现了如果 map 中元素个数大于 3 时，
我们就把队头的元素删除，当 put(1, 1) 执行的时候，正好把队头的 10 删除，
这个体现了达到我们设定的删除策略时，会自动的删除头节点。</p> <p>当我们调用 map.get(9) 方法时，元素 9 移动到队尾，调用 map.get(20) 方法时，
元素 20 被移动到队尾，这个体现了经常被访问的节点会被移动到队尾。</p> <p>这个例子就很好的说明了访问最少删除策略，接下来我们看下原理。</p> <p><strong>3.2.2 元素被转移到队尾</strong></p> <p>我们先来看下为什么 get 时，元素会被移动到队尾：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
       <span class="token comment">// 调用 HashMap  get 方法</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
           <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
       <span class="token comment">// 如果设置了 LRU 策略</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
       <span class="token comment">// 这个方法把当前 key 移动到队尾</span>
           <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>从上述源码中，可以看到，通过 afterNodeAccess 方法把当前访问节点移动到了队尾，
其实不仅仅是 get 方法，执行 getOrDefault、compute、computeIfAbsent、
computeIfPresent、merge 方法时，也会这么做，
通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。</p> <p>3.2.3 删除策略
上述 demo 我们在执行 put 方法时，发现队头元素被删除了，
LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，
但 LinkedHashMap 实现了 put 方法中的调用 afterNodeInsertion 方法，
这个方式实现了删除，我们看下源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 删除很少被访问的元素，被 HashMap 的 put 方法所调用</span>
   <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
       <span class="token comment">// 得到元素头节点</span>
       <span class="token class-name">LinkedHashMap</span><span class="token punctuation">.</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">;</span>
       <span class="token comment">// removeEldestEntry 来控制删除策略，如果队列不为空，并且删除策略允许删除的情况下，删除头节点</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">K</span> key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
           <span class="token comment">// removeNode 删除头节点</span>
           <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>3.3 小结</strong></p> <p>LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。</p> <p><strong>总结</strong></p> <p>本小节主要说了 TreeMap 和 LinkedHashMap 的的数据结构，分析了两者的核心内容源码，
我们发现两者充分利用了底层数据结构的特性，TreeMap 利用了红黑树左小右大的特性进行排序，
LinkedHashMap 在 HashMap 的基础上简单地加了链表结构，就形成了节点的顺序，非常巧妙，很有意思，
大家可以在看源码的过程中，可以多想想设计思路，说不定会有不一样的感悟。</p> <h3 id="_10-map源码会问哪些面试题"><a href="#_10-map源码会问哪些面试题" class="header-anchor">#</a> 10 Map源码会问哪些面试题</h3> <p><strong>引导语</strong></p> <p>Map 在面试中，占据了很大一部分的面试题目，其中以 HashMap 为主，这些面试题目有的可以说得清楚，
有的很难说清楚，如果是面对面面试的话，建议画一画。</p> <p><strong>1 Map 整体数据结构类问题</strong></p> <p><strong>1.1 说一说 HashMap 底层数据结构</strong></p> <p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，
时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，
数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，
单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，
链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p> <p><strong>1.2 HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</strong></p> <p>答：相同点：</p> <ol><li>三者在特定的情况下，都会使用红黑树；</li> <li>底层的 hash 算法相同；</li> <li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li></ol> <p>不同点：</p> <ol><li>HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li> <li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li> <li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li></ol> <p><strong>1.3 说一下 Map 的 hash 算法</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">int</span> h<span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   key 在数组中的位置公式：tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如上代码是 HashMap 的hash 算法。</p> <p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，
因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，
这么做的好处是使大多数场景下，算出来的 hash 值比较分散。</p> <p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，
可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，
就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，
但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），
所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p> <p>此问题可以延伸出三个小问题：</p> <p>1：为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</p> <p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p> <p>2：计算 hash 值时，为什么需要右移 16 位？</p> <p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p> <p>3：为什么把取模操作换成了 &amp; 操作？</p> <p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p> <p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p> <p>4：为什么提倡数组大小是 2 的幂次方？</p> <p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p> <p><strong>1.4 为解决 hash 冲突，大概有哪些办法。</strong></p> <p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p> <p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p> <p>3：hash 冲突发生时，采用链表来解决;</p> <p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p> <p>网上列举的一些其它办法，如开放定址法，尽量不要说，因为这些方法资料很少，实战用过的人更少，如果你没有深入研究的话，面试官让你深入描述一下很难说清楚，反而留下不好的印象，说 HashMap 现有的措施就足够了。</p> <p><strong>2 HashMap 源码细节类问题</strong></p> <p><strong>2.1 HashMap 是如何扩容的？</strong></p> <p>答：扩容的时机：</p> <ol><li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li> <li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;
扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</li></ol> <p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p> <p><strong>2.2 hash 冲突时怎么办？</strong></p> <p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p> <p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p> <p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p> <ol><li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li> <li>如果数组大小大于 64 时，链表就会转化成红黑树。
这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，
猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，
我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</li></ol> <p><strong>2.3 为什么链表个数大于等于 8 时，链表要转化成红黑树了？</strong></p> <p>答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，
但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，
链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，
这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，
导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p> <p>延伸问题：红黑树什么时候转变成链表。</p> <p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p> <p><strong>2.4 HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</strong></p> <p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，
这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，
内置 onlyIfAbsent 为 false，是允许覆盖的。</p> <p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，
第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，
当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p> <p><strong>2.5 通过以下代码进行删除，是否可行？</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span> <span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>答：不行，会报错误 ConcurrentModificationException，原因如下图：</p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/09.jpeg" alt="09"></p> <p>建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理，我们在《List 源码会问那些面试题》中有说到。</p> <p><strong>2.6 描述一下 HashMap get、put 的过程</strong></p> <p>答：我们在源码解析中有说，可以详细描述下源码的实现路径，说不清楚的话，可以画一画。</p> <p><strong>3 其它 Map 面试题</strong></p> <p><strong>3.1 DTO 作为 Map 的 key 时，有无需要注意的点？</strong></p> <p>答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，
我们可以对这些属性进行 get、set 操作。</p> <p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，
因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，
DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；
如果是 LinkedHashMap 的话，和 HashMap 一样的。</p> <p><strong>3.2 LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</strong></p> <p>答：LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，
也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，
使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，
LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。</p> <p>保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，
移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。</p> <p><strong>3.3 为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</strong>
答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，
所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展，
而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，
不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p> <p><strong>总结</strong></p> <p>Map 的面试题主要是 HashMap 为主，会问很多源码方面的东西，TreeMap 和
LinkedHashMap 主要以功能和场景为主，作为加分项。<br>
Map 的面试题型很多，但只要弄懂原理，题目再多变化，回答起来都会比较简单。</p> <h3 id="_11-hashset、treeset-源码解析"><a href="#_11-hashset、treeset-源码解析" class="header-anchor">#</a> 11 HashSet、TreeSet 源码解析</h3> <p><strong>引导语</strong></p> <p>HashSet、TreeSet 两个类是在 Map 的基础上组装起来的类，我们学习的侧重点，
主要在于 Set 是如何利用 Map 现有的功能，来达成自己的目标的，
也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p> <p><strong>1 HashSet</strong></p> <p><strong>1.1 类注释</strong></p> <p>看源码先看类注释上，我们可以得到的信息有：</p> <ol><li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li> <li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，
这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，
时间复杂度都是 O (1)；</li> <li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li> <li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。
我们之前也看过 List、Map 的类注释，我们发现 2、3、4 点信息在类注释中都有提到，
所以如果有人问 List、Map、 Set 三者的共同点，那么就可以说 2、3、4 三点。</li></ol> <p><strong>1.2 HashSet 是如何组合 HashMap 的</strong></p> <p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，
要基于基础类进行创新实现，有两种办法：</p> <ul><li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li> <li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li></ul> <p>HashSet 使用的就是组合 HashMap，其优点如下：</p> <ol><li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，
而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li> <li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，
而且方法命名可以任意命名，无需和基础类的方法名称保持一致。
我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</li></ol> <p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span>
   <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>
   <span class="token comment">// HashMap 中的 value</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>从这两行代码中，我们可以看出两点：</p> <ol><li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，
value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；
如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，
因为在后续的所有操作中，并没有加锁。</li> <li>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，
接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，
使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，
一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</li></ol> <p><strong>1.2.1 初始化</strong></p> <p>HashSet 的初始化比较简单，直接 new HashMap 即可，比较有意思的是，
当有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 对 HashMap 的容量进行了计算</span>
   <span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">.75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上述代码中：Math.max ((int) (c.size ()/.75f) + 1, 16)，
就是对 HashMap 的容量进行了计算，翻译成中文就是 取括号中两个数的最大值（期望的值 / 0.75+1，
默认值 16），从计算中，我们可以看出 HashSet 的实现者对 HashMap 的底层实现是非常清楚的，
主要体现在两个方面：</p> <ol><li>和 16 比较大小的意思是说，如果给定 HashMap 初始容量小于 16 ，就按照 HashMap 默认的 16 初始化好了，如果大于 16，就按照给定值初始化。</li> <li>HashMap 扩容的伐值的计算公式是：Map 的容量 * 0.75f，一旦达到阀值就会扩容，此处用 (int) (c.size ()/.75f) + 1 来表示初始化的值，这样使我们期望的大小值正好比扩容的阀值还大 1，就不会扩容，符合 HashMap 扩容的公式。</li></ol> <p>从简单的构造器中，我们就可以看出要很好的组合 api 接口，并没有那么简单，我们可能需要去了解一下被组合的 api 底层的实现，这样才能用好 api。</p> <p>同时这种写法，也提供了一种思路给我们，如果有人问你，往 HashMap 拷贝大集合时，如何给 HashMap 初始化大小时，完全可以借鉴这种写法：取最大值（期望的值 / 0.75 + 1，默认值 16）。</p> <p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下的 add 方法实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 直接使用 HashMap 的 put 方法，进行一些简单的逻辑判断</span>
       <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>从 add 方法中，我们就可以看到组合的好处，方法的入参、名称、返回值都可以自定义，如果是继承的话就不行了。</p> <p><strong>1.2.2 小结</strong></p> <p>HashSet 具体实现值得我们借鉴的地方主要有如下地方，我们平时写代码的时候，完全可以参考参考：</p> <ol><li>对组合还是继承的分析和把握；</li> <li>对复杂逻辑进行一些包装，使吐出去的接口尽量简单好用；</li> <li>组合其他 api 时，尽量多对组合的 api 多些了解，这样才能更好的使用 api；</li> <li>HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。</li></ol> <p><strong>2 TreeSet</strong></p> <p>TreeSet 大致的结构和 HashSet 相似，底层组合的是 TreeMap，
所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代，
我们主要来看复用 TreeMap 时，复用的两种思路：</p> <p><strong>2.1 复用 TreeMap 的思路一</strong></p> <p>场景一： TreeSet 的 add 方法，我们来看下其源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看到，底层直接使用的是 HashMap 的 put 的能力，直接拿来用就好了。</p> <p><strong>2.2 复用 TreeMap 的思路二</strong></p> <p>场景二：需要迭代 TreeSet 中的元素，那应该也是像 add 那样，直接使用 HashMap 已有的迭代能力，比如像下面这样：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 模仿思路一的方式实现</span>
   <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 直接使用 HashMap.keySet 的迭代能力</span>
       <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这种是思路一的实现方式，TreeSet 组合 TreeMap，直接选择 TreeMap 的底层能力进行包装，但 TreeSet 实际执行的思路却完全相反，我们看源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// NavigableSet 接口，定义了迭代的一些规范，和一些取值的特殊方法</span>
   <span class="token comment">// TreeSet 实现了该方法，也就是说 TreeSet 本身已经定义了迭代的规范</span>
   <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NavigableSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">SortedSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
       <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">E</span> <span class="token function">lower</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>  
   <span class="token comment">// m.navigableKeySet() 是 TreeMap 写了一个子类实现了 NavigableSet</span>
   <span class="token comment">// 接口，实现了 TreeSet 定义的迭代规范</span>
   <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">navigableKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>TreeMap 中对 NavigableSet 接口的实现源码截图如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/10.jpeg" alt="10">
从截图中（截图是在 TreeMap 中），我们可以看出 TreeMap 实现了 TreeSet 定义的各种特殊方法。</p> <p>我们可以看到，这种思路是 TreeSet 定义了接口的规范，TreeMap 负责去实现，实现思路和思路一是相反的。</p> <p>我们总结下 TreeSet 组合 TreeMap 实现的两种思路：</p> <ol><li>TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。</li> <li>TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现。
方案 1 和 2 的调用关系，都是 TreeSet 调用 TreeMap，但功能的实现关系完全相反，第一种是功能的定义和实现都在 TreeMap，TreeSet 只是简单的调用而已，第二种 TreeSet 把接口定义出来后，让 TreeMap 去实现内部逻辑，TreeSet 负责接口定义，TreeMap 负责具体实现，这样子的话因为接口是 TreeSet 定义的，所以实现一定是 TreeSet 最想要的，TreeSet 甚至都不用包装，可以直接把返回值吐出去都行。</li></ol> <p>我们思考下这两种复用思路的原因：</p> <ol><li>像 add 这些简单的方法，我们直接使用的是思路 1，主要是 add 这些方法实现比较简单，没有复杂逻辑，所以 TreeSet 自己实现起来比较简单；</li> <li>思路 2 主要适用于复杂场景，比如说迭代场景，TreeSet 的场景复杂，比如要能从头开始迭代，比如要能取第一个值，比如要能取最后一个值，再加上 TreeMap 底层结构比较复杂，TreeSet 可能并不清楚 TreeMap 底层的复杂逻辑，这时候让 TreeSet 来实现如此复杂的场景逻辑，TreeSet 就搞不定了，不如接口让 TreeSet 来定义，让 TreeMap 去负责实现，TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。</li></ol> <p><strong>2.3 小结</strong></p> <p>TreeSet 对 TreeMap 的两种不同复用思路，很重要，在工作中经常会遇到，特别是思路二，比如说 dubbo 的泛化调用，DDD 中的依赖倒置等等，原理都是 TreeSet 第二种的复用思想。</p> <p><strong>3 面试题</strong></p> <p>HashSet 和 TreeSet 的面试概率比不上 List 和 Map，但只要有机会，并把本文的内容表达出来，绝对是加分项，因为现在 List 和 Map 面试题太多，面试官认为你能答的出来是应该的，但只要你有机会对 HashSet 和 TreeSet 说出本文见解，并且说自己是看源码时领悟到的，绝对肯定是加分项，这些就是你超过面试官预期的惊喜，以下是一些常用的题目：</p> <p><strong>3.1 TreeSet 有用过么，平时都在什么场景下使用？</strong></p> <p>答：有木有用过如实回答就好了，我们一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。</p> <p><strong>3.2 追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？</strong></p> <p>答：要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。</p> <p><strong>3.3 追问，如果我想对 key 进行去重，有什么好的办法么？</strong></p> <p>答：我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。</p> <p><strong>3.4 说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</strong></p> <p>答： HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。</p> <p>TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。</p> <p><strong>总结</strong></p> <p>本小节主要说了 Set 源码中两处亮点：</p> <ol><li>HashSet 对组合的 HashMap 类扩容的门阀值的深入了解和设计，值得我们借鉴；</li> <li>TreeSet 对 TreeMap 两种复用思路，值得我们学习，特别是第二种复用思路。
HashSet 和 TreeSet 不会是面试的重点，但通过以上两点，可以让我们给面试官一种精益求精的感觉，成为加分项。</li></ol> <h3 id="_12-彰显细节：看集合源码对我们实际工作的帮助和应用"><a href="#_12-彰显细节：看集合源码对我们实际工作的帮助和应用" class="header-anchor">#</a> 12 彰显细节：看集合源码对我们实际工作的帮助和应用</h3> <p>本节中，我们先跳出源码的视角，来看看集合类的类图，看看在设计层面上，是否有可疑借鉴之处，接着通过源码来找找工作中的集合坑，提前扫雷。</p> <p><strong>1 集合类图</strong></p> <p><img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/11.jpeg" alt="11"></p> <p>上图是目前我们已学的集合类图，大概可以看出以下几点：</p> <ol><li>每个接口做的事情非常明确，比如 Serializable，只负责序列化，Cloneable 只负责拷贝，Map 只负责定义 Map 的接口，整个图看起来虽然接口众多，但职责都很清晰；</li> <li>复杂功能通过接口的继承来实现，比如 ArrayList 通过实现了 Serializable、Cloneable、RandomAccess、AbstractList、List 等接口，从而拥有了序列化、拷贝、对数组各种操作定义等各种功能；</li> <li>上述类图只能看见继承的关系，组合的关系还看不出来，比如说 Set 组合封装 Map 的底层能力等。</li></ol> <p>上述设计的最大好处是，每个接口能力职责单一，众多的接口变成了接口能力的积累，假设我们想再实现一个数据结构类，我们就可以从这些已有的能力接口中，挑选出能满足需求的能力接口，进行一些简单的组装，从而加快开发速度。</p> <p>这种思想在平时的工作中也经常被使用，我们会把一些通用的代码块抽象出来，沉淀成代码块池，碰到不同的场景的时候，我们就从代码块池中，把我们需要的代码块提取出来，进行简单的编排和组装，从而实现我们需要的场景功能。</p> <p><strong>2 集合工作中一些注意事项</strong></p> <p><strong>2.1 线程安全</strong></p> <p>我们说集合都是非线程安全的，这里说的非线程安全指的是集合类作为共享变量，被多线程读写的时候，才是不安全的，如果要实现线程安全的集合，在类注释中，JDK 统一推荐我们使用 Collections.synchronized* 类， Collections 帮我们实现了 List、Set、Map 对应的线程安全的方法， 如下图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/12.jpeg" alt="12">
图中实现了各种集合类型的线程安全的方法，我们以 synchronizedList 为例，从源码上来看下，Collections 是如何实现线程安全的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// mutex 就是我们需要锁住的对象</span>
   <span class="token keyword">final</span> <span class="token class-name">Object</span> mutex<span class="token punctuation">;</span>  
   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
           <span class="token keyword">extends</span> <span class="token class-name">SynchronizedCollection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>
           <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
           <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">7754090372962971524L</span><span class="token punctuation">;</span>
           <span class="token comment">// 这个 List 就是我们需要保证线程安全的类</span>
           <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>
           <span class="token class-name">SynchronizedList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">,</span> <span class="token class-name">Object</span> mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">super</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
   				<span class="token comment">// 我们可以看到，List 的所有操作都使用了 synchronized 关键字，来进行加锁</span>
   				<span class="token comment">// synchronized 是一种悲观锁，能够保证同一时刻，只能有一个线程能够获得锁</span>
           <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
   …………
   <span class="token punctuation">}</span>      
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>从源码中我们可以看到 Collections 是通过 synchronized 关键字给 List 操作数组的方法加上锁，来实现线程安全的。</p> <p><strong>2.2 集合性能</strong></p> <p>集合的单个操作，一般都没有性能问题，性能问题主要出现的批量操作上。</p> <p><strong>2.2.1 批量新增</strong></p> <p>在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增，以 ArrayList 为例写了一个 demo 如下，演示了两种方案的性能对比：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token annotation punctuation">@Test</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatchInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token comment">// 准备拷贝数据</span>
     <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   
     <span class="token comment">// for 循环 + add</span>
     <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">long</span> start1 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;单个 for 循环新增 300 w 个，耗时{}&quot;</span><span class="token punctuation">,</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token comment">// 批量新增</span>
     <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">long</span> start2 <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     list3<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;批量新增 300 w 个，耗时{}&quot;</span><span class="token punctuation">,</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>最后打印出来的日志为：</p> <p>16:52:59.865 [main] INFO demo.one.ArrayListDemo - 单个 for 循环新增 300 w 个，耗时1518
16:52:59.880 [main] INFO demo.one.ArrayListDemo - 批量新增 300 w 个，耗时8</p> <p>可以看到，批量新增方法性能是单个新增方法性能的 189 倍，主要原因在于批量新增，只会扩容一次，大大缩短了运行时间，而单个新增，每次到达扩容阀值时，都会进行扩容，在整个过程中就会不断的扩容，浪费了很多时间，我们来看下批量新增的源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
     <span class="token comment">// 确保容量充足，整个过程只会扩容一次</span>
     <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span> 
     <span class="token comment">// 进行数组的拷贝</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>
     size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>
     <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>以上是 ArrayList 批量新增的演示，我们可以看到，整个批量新增的过程中，只扩容了一次，HashMap 的 putAll 方法也是如此，整个新增过程只会扩容一次，大大缩短了批量新增的时间，提高了性能。</p> <p>所以如果有人问你当碰到集合批量拷贝，批量新增场景，如何提高新增性能的时候 ，就可以从目标集合初始化方面应答。</p> <p>这里也提醒了我们，在容器初始化的时候，最好能给容器赋上初始值，这样可以防止在 put 的过程中不断的扩容，从而缩短时间，上章 HashSet 的源码给我们演示了，给 HashMap 赋初始值的公式为：取括号内两者的最大值（期望的值/0.75+1，默认值 16）。</p> <p><strong>2.2.2 批量删除</strong></p> <p>批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法，我们一起来看下 removeAll 的源码实现，是如何提高性能的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 批量删除，removeAll 方法底层调用的是 batchRemove 方法</span>
   <span class="token comment">// complement 参数默认是 false,false 的意思是数组中不包含 c 中数据的节点往头移动</span>
   <span class="token comment">// true 意思是数组中包含 c 中数据的节点往头移动，这个是根据你要删除数据和原数组大小的比例来决定的</span>
   <span class="token comment">// 如果你要删除的数据很多，选择 false 性能更好，当然 removeAll 方法默认就是 false。</span>
   <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">,</span> <span class="token keyword">boolean</span> complement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
     <span class="token comment">// r 表示当前循环的位置、w 位置之前都是不需要被删除的数据，w 位置之后都是需要被删除的数据</span>
     <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
       <span class="token comment">// 从 0 位置开始判断，当前数组中元素是不是要被删除的元素，不是的话移到数组头</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> complement<span class="token punctuation">)</span>
           elementData<span class="token punctuation">[</span>w<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
       <span class="token comment">// r 和 size 不等，说明在 try 过程中发生了异常，在 r 处断开</span>
       <span class="token comment">// 把 r 位置之后的数组移动到 w 位置之后(r 位置之后的数组数据都是没有判断过的数据，这样不会影响没有判断的数据，判断过的数据可以被删除)</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> r<span class="token punctuation">,</span>
                          elementData<span class="token punctuation">,</span> w<span class="token punctuation">,</span>
                          size <span class="token operator">-</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
         w <span class="token operator">+=</span> size <span class="token operator">-</span> r<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// w != size 说明数组中是有数据需要被删除的</span>
       <span class="token comment">// 如果 w、size 相等，说明没有数据需要被删除</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// w 之后都是需要删除的数据，赋值为空，帮助 gc。</span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> w<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
           elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
         modCount <span class="token operator">+=</span> size <span class="token operator">-</span> w<span class="token punctuation">;</span>
         size <span class="token operator">=</span> w<span class="token punctuation">;</span>
         modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">return</span> modified<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>我们看到 ArrayList 在批量删除时，如果程序执行正常，只有一次 for 循环，如果程序执行异常，才会加一次拷贝，而单个 remove 方法，每次执行的时候都会进行数组的拷贝（当删除的元素正好是数组最后一个元素时除外），当数组越大，需要删除的数据越多时，批量删除的性能会越差，所以在 ArrayList 批量删除时，强烈建议使用 removeAll 方法进行删除。</p> <p><strong>2.3 集合的一些坑</strong></p> <ol><li><p>当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。
在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，这个在之前的源码解析中，我们有说到，所以当集合的元素是自定义类时，我们强烈建议覆写 equals 和 hashCode 方法，我们可以直接使用 IDEA 工具覆写这两个方法，非常方便；</p></li> <li><p>所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；</p></li> <li><p>我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑，代码演示坑为：</p></li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testArrayToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token comment">// 坑1：修改数组的值，会直接影响原 list</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;数组被修改之前，集合第一个元素为：{}&quot;</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;数组被修改之前，集合第一个元素为：{}&quot;</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token comment">// 坑2：使用 add、remove 等操作 list 的方法时，</span>
     <span class="token comment">// 会报 UnsupportedOperationException 异常</span>
     list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   坑 <span class="token number">1</span>：数组被修改后，会直接影响到新 <span class="token class-name">List</span> 的值。
   坑 <span class="token number">2</span>：不能对新 <span class="token class-name">List</span> 进行 add、remove 等操作，否则运行时会报 <span class="token class-name">UnsupportedOperationException</span> 错误。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>我们来看下 Arrays.asList 的源码实现，就能知道问题所在了，源码如下图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/13.jpeg" alt="13"></p> <p>从上图中，我们可以发现，Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现 add、remove 等方法，这些就是坑 1 和 2 的原因。</p> <ol start="4"><li>集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险，稍微不注意，就踩进大坑，我们示例代码如下：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   
       <span class="token comment">// 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],</span>
       <span class="token comment">// 无法向下转化成 List&lt;Integer&gt;，编译都无法通过</span>
       <span class="token comment">// List&lt;Integer&gt; list2 = list.toArray();</span>
   
       <span class="token comment">// 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况</span>
       <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array0<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;toArray 数组大小不够，array0 数组[0] 值是{},数组[1] 值是{},&quot;</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   		
       <span class="token comment">// 演示数组初始化大小正好，正好转化成数组</span>
       <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;toArray 数组大小正好，array1 数组[3] 值是{}&quot;</span><span class="token punctuation">,</span>array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
       <span class="token comment">// 演示数组初始化大小大于实际所需大小，也可以转化成数组</span>
       <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;toArray 数组大小多了，array2 数组[3] 值是{}，数组[4] 值是{}&quot;</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.687</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span><span class="token class-name">ArrayListDemo</span> <span class="token operator">-</span> toArray 数组大小不够，array0 数组<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 值是<span class="token keyword">null</span><span class="token punctuation">,</span>数组<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 值是<span class="token keyword">null</span><span class="token punctuation">,</span>
   <span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span><span class="token class-name">ArrayListDemo</span> <span class="token operator">-</span> toArray 数组大小正好，array1 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span>
   <span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span><span class="token class-name">ArrayListDemo</span> <span class="token operator">-</span> toArray 数组大小多了，array2 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span>，数组<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> 值是<span class="token keyword">null</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>toArray 的无参方法，无法强转成具体类型，这个编译的时候，就会有提醒，我们一般都会去使用带有参数的 toArray 方法，这时就有一个坑，如果参数数组的大小不够，这时候返回的数组值竟然是空，上述代码中的 array0 的返回值就体现了这点，但我们去看 toArray 源码，发现源码中返回的是 4 个大小值的数据，返回的并不是空，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// List 转化成数组</span>
   <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 如果数组长度不够，按照 List 的大小进行拷贝，return 的时候返回的都是正确的数组</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>
       <span class="token comment">// Make a new array of a's runtime type, but my contents:</span>
       <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// 数组长度大于 List 大小的，赋值为 null</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>
       a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> a<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>从源码中，我们丝毫看不出为什么 array0 的元素值为什么是 null，最后我们去看方法的注释，发现是这样子描述的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">If</span> the list fits in the specified array<span class="token punctuation">,</span> it is returned therein<span class="token punctuation">.</span>  <span class="token class-name">Otherwise</span><span class="token punctuation">,</span> a <span class="token keyword">new</span> array is
    allocated <span class="token keyword">with</span> the runtime type of the specified array and the size of <span class="token keyword">this</span> list。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>翻译过来的意思就是说：如果返回的数组大小和申明的数组大小一致，那么就会正常返回，否则，一个新数组就会被分配返回。</p> <p>所以我们在使用有参 toArray 方法时，申明的数组大小一定要大于等于 List 的大小，如果小于的话，你会得到一个空数组。</p> <p><strong>3 总结</strong></p> <p>本小节，我们详细描述了集合的线程安全、性能优化和日常工作中一些坑，这些问题我们在工作中经常会碰到，稍不留神就会引发线上故障，面试的时候也经常会通过这些问题，来考察大家的工作经验，所以阅读本章时，建议大家自己动手试一试，加深印象。</p> <h3 id="_13-差异对比：集合在-java-7-和-8-有何不同和改进"><a href="#_13-差异对比：集合在-java-7-和-8-有何不同和改进" class="header-anchor">#</a> 13 差异对比：集合在 Java 7 和 8 有何不同和改进</h3> <p><strong>引导语</strong></p> <p>Java 8 在 Java 7 的基础上，做了一些改进和优化，但我们在平时工作中，或者直接升级到 Java 8 的过程中，我们好像无需做任何兼容逻辑，那么 Java 8 底层是如何处理的呢，在改进的同时，是如何优雅兼容 Java 老版本，让使用者无需感知，接下来我们通过对比 Java 7 和 8 的差异，来展示 Java 8 是如何优雅升级的。</p> <p><strong>1 通用区别</strong></p> <p><strong>1.1 所有集合都新增了forEach 方法</strong></p> <p>List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口，我们以 ArrayList 的 forEach 的源码为例，来看下方法是如何实现的 ：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token annotation punctuation">@Override</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 判断非空</span>
     <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// modCount的原始值被拷贝</span>
     <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
     <span class="token keyword">final</span> <span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
     <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
     <span class="token comment">// 每次循环都会判断数组有没有被修改，一旦被修改，停止循环</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 执行循环内容，action 代表我们要干的事情</span>
       action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 数组如果被修改了，抛异常</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>从这段源码中，很容易产生两个问题：</p> <p>1、action.accept 到底是个啥？</p> <p>action.accept 就是你在 for 循环中要干的事情，你可以进行任何事情，比如我们打印一句话，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testForEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     <span class="token comment">// value 是每次循环的入参，就是 list 中的每个元素</span>
     list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> value<span class="token operator">-&gt;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;当前值为：{}&quot;</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   输出为：
   当前值为：<span class="token number">1</span>
   当前值为：<span class="token number">3</span>
   当前值为：<span class="token number">2</span>
   当前值为：<span class="token number">4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>log.info(“当前值为：{}”,value) 就是我们要干的事情，就是 action。</p> <p>2.、forEach 方法上打了 @Override 注解，说明该方法是被继承实现的，该方法是被定义在 Iterable 接口上的，Java 7 和 8 的 ArrayList 都实现了该接口，但我们在 Java 7 的 ArrayList 并没有发现有实现该方法，编译器也木有报错，这个主要是因为 Iterable 接口的 forEach 方法被加上了 default 关键字，这个关键字只会出现在接口类中，被该关键字修饰的方法无需强制要求子类继承，但需要自己实现默认实现，我们看下源码：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/14.jpeg" alt="14">
不仅仅是 forEach 这一个方法是这么干的，List、Set、Map 接口中很多新增的方法都是这么干的，通过 default 关键字，可以让 Java 7 的集合子类无需实现 Java 8 中新增的方法。</p> <p>如果想在接口中新增一个方法，但又不想子类强制实现该方法时，可以给该方法加上 default 关键字，这个在实际工作中，也经常使用到，算是重构的小技巧吧。</p> <p><strong>1.2 List 区别</strong></p> <p><strong>1.2.1 ArrayList</strong></p> <p>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容，下图是源码的差异对比图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/15.jpeg" alt="15">
List 其它方面 java7 和 8 并没有改动。</p> <p><strong>1.3 Map 区别</strong></p> <p><strong>1.3.1 HashMap</strong></p> <ol><li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li> <li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li> <li>Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。</li></ol> <p>也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。</p> <p>新增了一些好用的方法，比如 getOrDefault，我们看下源码，非常简单：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 如果 key 对应的值不存在，返回期望的默认值 defaultValue</span>
   <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> defaultValue <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>还有 putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。</p> <p>还有 compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算，demo 如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>     <span class="token annotation punctuation">@Test</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;compute 之前值为：{}&quot;</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;compute 之后值为：{}&quot;</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 还原测试值</span>
       map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
       <span class="token comment">// 如果为 11 的 key 不存在的话，需要注意 value 为空的情况，下面这行代码就会报空指针</span>
       <span class="token comment">//  map.compute(11,(key,value) -&gt; key * value);</span>
       
       <span class="token comment">// 为了防止 key 不存在时导致的未知异常，我们一般有两种办法</span>
       <span class="token comment">// 1：自己判断空指针</span>
       map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">null</span> <span class="token operator">==</span> value <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 2：computeIfPresent 方法里面判断</span>
       map<span class="token punctuation">.</span><span class="token function">computeIfPresent</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
       log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;computeIfPresent 之后值为：{}&quot;</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   结果是：
   compute 之前值为：<span class="token number">10</span>
   compute 之后值为：<span class="token number">100</span>
   computeIfPresent 之后值为：<span class="token keyword">null</span>（这个结果中，可以看出，使用 computeIfPresent 避免了空指针）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量，computeIfPresent 的源码就不贴了，有兴趣可以去 github 上面查看，主要的实现原理如下：</p> <ul><li>找到 key 对应的老值，会分别从数组、链表、红黑树中找；</li> <li>根据 key 和老值进行计算，得到新值；</li> <li>用新值替换掉老值，可能是普通替换、链表替换或红黑树替换。</li></ul> <p><strong>1.3.2 LinkedHashMap</strong></p> <p>由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同，我们看下面的图，左边是 Java 7，右边是 Java 8。
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/16.jpeg" alt="16">
从图中，我们发现 LinkedHashMap 的方法名有所修改，底层的实现逻辑其实都差不多的。</p> <p><strong>1.4 其他区别</strong></p> <p><strong>1.4.1 Arrays 提供了很多 parallel 开头的方法。</strong></p> <p>Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。</p> <p><strong>1.5 面试题</strong></p> <ol><li>Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</li></ol> <p>答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p> <ol start="2"><li>Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？</li></ol> <p>答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。</p> <ol start="3"><li>说说 computeIfPresent 方法的使用姿势？</li></ol> <p>答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。</p> <ol start="4"><li>Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？</li></ol> <p>答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p> <ol start="5"><li>HashMap 8 和 7 有啥区别？</li></ol> <p>答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。</p> <p><strong>总结</strong></p> <p>总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。</p> <p>想要了解更多差异，也可直接前往 JDK 8 新特性查看，地址为：<a href="http://openjdk.java.net/projects/jdk8/features#103" target="_blank" rel="noopener noreferrer">http://openjdk.java.net/projects/jdk8/features#103<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="_14-简化工作：guava-lists-maps-实际工作运用和源码"><a href="#_14-简化工作：guava-lists-maps-实际工作运用和源码" class="header-anchor">#</a> 14 简化工作：Guava Lists Maps 实际工作运用和源码</h3> <p><strong>引导语</strong></p> <p>在日常工作中，我们经常会使用一些三方的 API 来简化我们的工作，Guava 就是其中一种，Guava 是 Google 开源的技术框架，使用率高，社区活跃度也很高。</p> <p>本小节我们从工作中对 Guava 集合的使用入手，然后深入的看下其底层的实现，最后总结其设计思想，感兴趣的同学也可以下载源码学习，GitHub 地址：<a href="https://github.com/google/guava" target="_blank" rel="noopener noreferrer">https://github.com/google/guava<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，源码中 guava 的文件夹为其源码。</p> <p>1 运用工厂模式进行初始化
在集合类初始化方面，Guava 比 Java 原生的 API 更加好用，还发明了很多新的功能，比如说在 JDK 7 之前，我们新建集合类时，声明和初始化都必须写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;泛型&gt;();</code> ， JDK 7 之后有所改变，我们只需要在声明处写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;&gt;();</code>。</p> <p>Guava 提供了更加方便的使用姿势，采用了工厂模式，把集合创建的逻辑交给了工厂，开发者无需关注工厂底层是如何创建的，只需要关心，工厂能产生什么，代码于是变成了这样：<code>List&lt;泛型&gt; list = Lists.newArrayList();</code>，Lists 就是 Guava 提供出来的，方便操作 List 的工具类。</p> <p>这种写法其实就是一种简单的工厂模式，只需要定义好工厂的入参和出参，就能对外隐藏其内部的创建逻辑，提供更加方便的使用体验。</p> <p>当然除了 Lists，Guava 还提供了很多其他实用工具，如 Maps、Sets，接下来我们分别来看下这些常用工具的使用和原理。</p> <p><strong>2 Lists</strong></p> <p><strong>2.1 初始化</strong></p> <p>Lists 最大的功能是能帮助我们进行 List 的初始化，比如我们刚说的 newArrayList 这种：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 这种底层是帮助我们写好了泛型，E 代表泛型，表示当前返回的泛型类型和声明的一致即可，在编译的时候，会把泛型 E 转化成我们声明的 String。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>如果你清楚 List 的大小，我们也可以这样做：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 可以预估 list 的大小为 20</span>
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayListWithCapacity</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 不太肯定 list 大小是多少，但期望是大小是 20 上下。</span>
   <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">newArrayListWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>newArrayListWithCapacity(20) 方法内部实现是：<code>new ArrayList&lt;&gt;(20);</code>，而 newArrayListWithExpectedSize 方法内部实现是对 List 大小有一个计算公式的，计算公式为：<code>5L + arraySize + (arraySize / 10)</code> ，arraySize 表示传进来的值，公式简化下就是 5 + 11/10 * arraySize，因为这个方法表示期望的大小，所以这里取的约是期望值的十分之十一，比传进来的值约大十分之一，所以根据 20 最终计算出来的值是 27。</p> <p>Lists 在初始化的时候，还支持传迭代器的入参（只适合小数据量的迭代器的入参），源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">// addAll 方法底层其实通过迭代器进行 for 循环添加</span>
     <span class="token class-name">Iterators</span><span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> list<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>从 Lists 对 List 初始化进行包装的底层源码来看，底层源码非常简单的，但我们还是愿意使用这种方式的包装，主要是因为这种工厂模式的包装，使我们的使用姿势更加优雅，使用起来更加方便。</p> <p><strong>2.2 分组和反转排序</strong></p> <p>除了初始化之外，Lists 还提供了两个比较实用的功能，分组和反转排序功能，我们分别来演示一下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 演示反转排序</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;反转之前：&quot;</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     list <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;反转之后：&quot;</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 打印出来的结果为：</span>
   反转之前：<span class="token punctuation">[</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">]</span>
   反转之后：<span class="token punctuation">[</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>reverse 方法底层实现非常巧妙，底层覆写了 List 原生的 get(index) 方法，会把传进来的 index 进行 (size - 1) - index 的计算，使计算得到的索引位置和 index 位置正好相反，这样当我们 get 时，数组索引位置的 index 已经是相反的位置了，达到了反转排序的效果，其实底层并没有进行反转排序，只是在计算相反的索引位置，通过计算相反的索引位置这样简单的设计，得到了反转排序的效果，很精妙。</p> <p>在工作中，有时候我们需要把一个大的 list 进行切分，然后再把每份丢给线程池去运行，最后将每份运行的结果汇总，Lists 工具类就提供了一个对 list 进行切分分组的方法，演示 demo 如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 分组</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPartition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;分组之前：&quot;</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> list2 <span class="token operator">=</span> <span class="token class-name">Lists</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;分组之后：&quot;</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   输出结果为：
   分组之前：<span class="token punctuation">[</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">]</span>
   分组之后：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&quot;10&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;20&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">&quot;40&quot;</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>partition 方法的第二个参数的意思，你想让分组后的 List 包含几个元素，这个方法的底层实现其实就是 subList 方法。</p> <p>有一点需要我们注意的是这两个方法返回的 List 并不是 ArrayList，是自定义的 List，所以对于 ArrayList 的有些功能可能并不支持，使用的时候最好能看下源码，看看底层有无支持。</p> <p><strong>2.3 小结</strong></p> <p>Lists 上述的方法大大的方便了我们进行开发，简化了使用姿势，但其内部实现却非常简单巧妙，比如说 reverse 方法可以输出相反排序的 List，但底层并没有实现排序，只是计算了索引位置的相反值而已，这点值得我们学习。</p> <p><strong>3 Maps</strong></p> <p><strong>3.1 初始化</strong></p> <p>Maps 也是有着各种初始化 Map 的各种方法，原理不说了，和 Lists 类似，我们演示下如何使用：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> hashMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> linkedHashMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newLinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 这里 Map 的初始化大小公式和 HashSet 初始化公式类似，还记得 HashSet 初始化 HashMap 时，经典的计算初始大小的公式么：取最大值（期望的值 / 0.75 + 1，默认值 16），newHashMapWithExpectedSize 方法底层也是这么算的初始化大小的</span>
   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> withExpectedSizeHashMap <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>3.2 difference</strong></p> <p>Maps 提供了一个特别有趣也很实用的方法：difference，此方法的目的是比较两个 Map 的差异，入参就是两个 Map，比较之后能够返回四种差异：</p> <ol><li>左边 Map 独有 key。</li> <li>右边 Map 独有 key。</li> <li>左右边 Map 都有 key，并且 value 相等。</li> <li>左右边 Map 都有 key，但是 value 不等。
我们用代码来演示一下：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// ImmutableMap.of 也是 Guava 提供初始化 Map 的方法，入参格式为 k1,v1,k2,v2,k3,v3……</span>
   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> leftMap <span class="token operator">=</span> <span class="token class-name">ImmutableMap</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> rightMap <span class="token operator">=</span> <span class="token class-name">ImmutableMap</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;30&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">MapDifference</span> difference <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">difference</span><span class="token punctuation">(</span>leftMap<span class="token punctuation">,</span> rightMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;左边 map 独有 key：{}&quot;</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;右边 map 独有 key：{}&quot;</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;左右边 map 都有 key，并且 value 相等：{}&quot;</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesInCommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;左右边 map 都有 key，但 value 不等：{}&quot;</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesDiffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   最后打印结果为：
   左边 map 独有 key：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
   右边 map 独有 key：<span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
   左右边 map 都有 key，并且 value 相等：<span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
   左右边 map 都有 key，但 value 不等：<span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>从这个 demo 我们可以看到此方法的强大威力，我们在工作中经常遇到 Map 或者 List 间比较差异的任务，我们就可以直接使用该方法进行对比，List 可以先转化成 Map。</p> <p>而且 difference 底层的实现也算是最优的实现了，只需要循环一遍，就可得到上述四种差异结果，源码解析如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 对比两个 map 的差异</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">doDifference</span><span class="token punctuation">(</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> left<span class="token punctuation">,</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> right<span class="token punctuation">,</span>
       <span class="token class-name">Equivalence</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> valueEquivalence<span class="token punctuation">,</span>
       <span class="token comment">// key 只在左边 map 出现</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> onlyOnLeft<span class="token punctuation">,</span>
       <span class="token comment">// key 只在右边 map 出现，调用 doDifference 方法前已经包含了全部右边的值</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> onlyOnRight<span class="token punctuation">,</span>
       <span class="token comment">// key 在左右 map 中都出现过，并且 value 都相等</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> onBoth<span class="token punctuation">,</span>
       <span class="token comment">// key 在左右 map 中都出现过，但 value 不等</span>
       <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token class-name">MapDifference</span><span class="token punctuation">.</span><span class="token class-name">ValueDifference</span><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> differences<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">// 以左边 map 为基准进行循环</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> left<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">K</span> leftKey <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">V</span> leftValue <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 右边 map 包含左边的 key</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// onlyOnRight 已经包含全部右边的值 所以需要删除当前 key</span>
         <span class="token class-name">V</span> rightValue <span class="token operator">=</span> onlyOnRight<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">// key 相等，并且 value 值也相等</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>valueEquivalence<span class="token punctuation">.</span><span class="token function">equivalent</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           onBoth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">// key 相等，但 value 值不等</span>
         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           differences<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> <span class="token class-name">ValueDifferenceImpl</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
       <span class="token comment">// 右边 map 不包含左边的 key，就是左边 map 独有的 key</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         onlyOnLeft<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>这是一种比较优秀的，快速比对的算法，可以好好看下上面的源码，然后把这种算法背下来，或者自己再次实现一次。</p> <p>Sets 的使用方式和 Lists 和 Maps 很类似，没有太大的亮点，我们就不说了。</p> <p><strong>4 总结</strong></p> <p>这一小节主要都是实战内容，在实际工作中可以用起来。</p> <p>在 Guava 对集合的设计中，有两个大点是非常值得我们学习的：</p> <p>Lists、Maps 的出现给我们提供了更方便的使用姿势和方法，我们在实际工作中，如果碰到特别繁琐，或者特别难用的 API，我们也可以进行一些包装，使更好用，这个是属于在解决目前的痛点的问题上进行创新，是非常值得提倡的一件事情，往往可以帮助你拿到更好的绩效。
如果有人问你，List 或者 Map 高效的差异排序算法，完全可以参考 Maps.difference 的内部实现，该方法只使用了一次循环，就可得到所有的相同或不同结果，这种算法在我们工作中也经常被使用。
了解更多，可以直接前往 Guava 的代码库查看：<a href="https://github.com/google/guava" target="_blank" rel="noopener noreferrer">https://github.com/google/guava<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="第3章-并发集合类"><a href="#第3章-并发集合类" class="header-anchor">#</a> 第3章 并发集合类</h2> <h3 id="_15-copyonwritearraylist-源码解析和设计思路"><a href="#_15-copyonwritearraylist-源码解析和设计思路" class="header-anchor">#</a> 15 CopyOnWriteArrayList 源码解析和设计思路</h3> <p><strong>引导语</strong></p> <p>在 ArrayList 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 Collections.synchronizedList 方法，其实 JDK 还提供了另外一种线程安全的 List，叫做 CopyOnWriteArrayList，这个 List 具有以下特征：</p> <ol><li>线程安全的，多线程环境下可以直接使用，无需加锁；</li> <li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</li> <li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li></ol> <p>1 整体架构
从整体架构上来说，CopyOnWriteArrayList 数据结构和 ArrayList 是一致的，底层是个数组，只不过 CopyOnWriteArrayList 在对数组进行操作的时候，基本会分四步走：</p> <p>加锁；
从原数组中拷贝出新数组；
在新数组上进行操作，并把新数组赋值给数组容器；
解锁。
除了加锁之外，CopyOnWriteArrayList 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下：
<code>private transient volatile Object[] array;</code>
整体上来说，CopyOnWriteArrayList 就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。</p> <p><strong>1.1 类注释</strong></p> <p>我们看看从 CopyOnWriteArrayList 的类注释上能得到哪些信息：</p> <ol><li>所有的操作都是线程安全的，因为操作都是在新拷贝数组上进行的；</li> <li>数组的拷贝虽然有一定的成本，但往往比一般的替代方案效率高；</li> <li>迭代过程中，不会影响到原来的数组，也不会抛出 ConcurrentModificationException 异常。</li></ol> <p>接着我们来看下 CopyOnWriteArrayList 的核心方法源码。</p> <p><strong>2 新增</strong></p> <p>新增有很多种情况，比如说：新增到数组尾部、新增到数组某一个索引位置、批量新增等等，操作的思路还是我们开头说的四步，我们拿新增到数组尾部的方法举例，来看看底层源码的实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 添加元素到数组尾部</span>
   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
       <span class="token comment">// 加锁</span>
       lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
           <span class="token comment">// 得到所有的原数组</span>
           <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
           <span class="token comment">// 拷贝到新数组里面，新数组的长度是 + 1 的，因为新增会多一个元素</span>
           <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">// 在新数组中进行赋值，新元素直接放在数组的尾部</span>
           newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
           <span class="token comment">// 替换掉原来的数组</span>
           <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token comment">// finally 里面释放锁，保证即使 try 发生了异常，仍然能够释放锁   </span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
           lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>从源码中，我们发现整个 add 过程都是在持有锁的状态下进行的，通过加锁，来保证同一时刻只能有一个线程能够对同一个数组进行 add 操作。</p> <p>除了加锁之外，还会从老数组中创建出一个新数组，然后把老数组的值拷贝到新数组上，这时候就有一个问题：都已经加锁了，为什么需要拷贝数组，而不是在原来数组上面进行操作呢，原因主要为：</p> <ol><li>volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行，也就说要对数组进行重新赋值才行。</li> <li>在新的数组上进行拷贝，对老数组没有任何影响，只有新数组完全拷贝完成之后，外部才能访问到，降低了在赋值过程中，老数组数据变动的影响。
简单 add 操作是直接添加到数组的尾部，接着我们来看下指定位置添加元素的关键源码（部分源码）：</li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// len：数组的长度、index：插入的位置</span>
   <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index<span class="token punctuation">;</span>
   <span class="token comment">// 如果要插入的位置正好等于数组的末尾，直接拷贝数组即可</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
       newElements <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果要插入的位置在数组的中间，就需要拷贝 2 次</span>
   <span class="token comment">// 第一次从 0 拷贝到 index。</span>
   <span class="token comment">// 第二次从 index+1 拷贝到末尾。</span>
       newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
            numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// index 索引位置的值是空的，直接赋值即可。</span>
   newElements<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
   <span class="token comment">// 把新数组的值赋值给数组的容器中</span>
   <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>从源码中可以看到，当插入的位置正好处于末尾时，只需要拷贝一次，当插入的位置处于中间时，此时我们会把原数组一分为二，进行两次拷贝操作。</p> <p>最后还有个批量新增操作，源码我们就不贴了，底层也是拷贝数组的操作。</p> <p><strong>2.1 小结</strong></p> <p>从 add 系列方法可以看出，CopyOnWriteArrayList 通过加锁 + 数组拷贝+ volatile 来保证了线程安全，每一个要素都有着其独特的含义：</p> <ol><li>加锁：保证同一时刻数组只能被一个线程操作；</li> <li>数组拷贝：保证数组的内存地址被修改，修改后触发 volatile 的可见性，其它线程可以立马知道数组已经被修改；</li> <li>volatile：值被修改后，其它线程能够立马感知最新值。
3 个要素缺一不可，比如说我们只使用 1 和 3 ，去掉 2，这样当我们修改数组中某个值时，并不会触发 volatile 的可见特性的，只有当数组内存地址被修改后，才能触发把最新值通知给其他线程的特性。</li></ol> <p><strong>3 删除</strong></p> <p>接着我们来看下指定数组索引位置删除的源码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 删除某个索引位置的数据</span>
   <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
       <span class="token comment">// 加锁</span>
       lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
           <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
           <span class="token comment">// 先得到老值</span>
           <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
           <span class="token comment">// 如果要删除的数据正好是数组的尾部，直接删除</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
               <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token comment">// 如果删除的数据在数组的中间，分三步走</span>
               <span class="token comment">// 1. 设置新数组的长度减一，因为是减少一个元素</span>
               <span class="token comment">// 2. 从 0 拷贝到数组新位置</span>
               <span class="token comment">// 3. 从新位置拷贝到数组尾部</span>
               <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
               <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                                numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
           lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>步骤分为三步：</p> <ol><li>加锁；</li> <li>判断删除索引的位置，从而进行不同策略的拷贝；</li> <li>解锁。</li></ol> <p>代码整体的结构风格也比较统一：锁 + try finally +数组拷贝，锁被 final 修饰的，保证了在加锁过程中，锁的内存地址肯定不会被修改，finally 保证锁一定能够被释放，数组拷贝是为了删除其中某个位置的元素。</p> <p><strong>4 批量删除</strong></p> <p>数组的批量删除很有意思，接下来我们来看下 CopyOnWriteArrayList 的批量删除的实现过程：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 批量删除包含在 c 中的元素</span>
   <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
       lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">try</span> <span class="token punctuation">{</span>
           <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
           <span class="token comment">// 说明数组有值，数组无值直接返回 false</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">// newlen 表示新数组的索引位置，新数组中存在不包含在 c 中的元素</span>
               <span class="token keyword">int</span> newlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
               <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
               <span class="token comment">// 循环，把不包含在 c 里面的元素，放到新数组中</span>
               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token class-name">Object</span> element <span class="token operator">=</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                   <span class="token comment">// 不包含在 c 中的元素，从 0 开始放到新数组中</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span>
                       temp<span class="token punctuation">[</span>newlen<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token comment">// 拷贝新数组，变相的删除了不包含在 c 中的元素</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>newlen <span class="token operator">!=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token function">setArray</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
           lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>从源码中，我们可以看到，我们并不会直接对数组中的元素进行挨个删除，而是先对数组中的值进行循环判断，把我们不需要删除的数据放到临时数组中，最后临时数组中的数据就是我们不需要删除的数据。</p> <p>不知道大家有木有似曾相识的感觉，ArrayList 的批量删除的思想也是和这个类似的，所以我们在需要删除多个元素的时候，最好都使用这种批量删除的思想，而不是采用在 for 循环中使用单个删除的方法，单个删除的话，在每次删除的时候都会进行一次数组拷贝(删除最后一个元素时不会拷贝)，很消耗性能，也耗时，会导致加锁时间太长，并发大的情况下，会造成大量请求在等待锁，这也会占用一定的内存。</p> <p><strong>5 其它方法</strong></p> <p><strong>5.1 indexOf</strong></p> <p>indexOf 方法的主要用处是查找元素在数组中的下标位置，如果元素存在就返回元素的下标位置，元素不存在的话返回 -1，不但支持 null 值的搜索，还支持正向和反向的查找，我们以正向查找为例，通过源码来说明一下其底层的实现方式：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// o：我们需要搜索的元素</span>
   <span class="token comment">// elements：我们搜索的目标数组</span>
   <span class="token comment">// index：搜索的开始位置</span>
   <span class="token comment">// fence：搜索的结束位置</span>
   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">,</span>
                              <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> fence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 支持对 null 的搜索</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
               <span class="token comment">// 找到第一个 null 值，返回下标索引的位置</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                   <span class="token keyword">return</span> i<span class="token punctuation">;</span>
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
           <span class="token comment">// 通过 equals 方法来判断元素是否相等</span>
           <span class="token comment">// 如果相等，返回元素的下标位置</span>
           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                   <span class="token keyword">return</span> i<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>indexOf 方法在 CopyOnWriteArrayList 内部使用也比较广泛，比如在判断元素是否存在时（contains），在删除元素方法中校验元素是否存在时，都会使用到 indexOf 方法，indexOf 方法通过一次 for 循环来查找元素，我们在调用此方法时，需要注意如果找不到元素时，返回的是 -1，所以有可能我们会对这个特殊值进行判断。</p> <p><strong>5.2 迭代</strong></p> <p>在 CopyOnWriteArrayList 类注释中，明确说明了，在其迭代过程中，即使数组的原值被改变，也不会抛出 ConcurrentModificationException 异常，其根源在于数组的每次变动，都会生成新的数组，不会影响老数组，这样的话，迭代过程中，根本就不会发生迭代数组的变动，我们截几个图说明一下：</p> <ol><li><p>迭代是直接持有原有数组的引用，也就是说迭代过程中，一旦原有数组的值内存地址发生变化，必然会影响到迭代过程，下图源码演示的是 CopyOnWriteArrayList 的迭代方法，我们可以看到迭代器是直接持有原数组的引用：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/17.jpeg" alt="17"></p></li> <li><p>我们写了一个 demo，在 CopyOnWriteArrayList 迭代之后，往 CopyOnWriteArrayList 里面新增值，从下图中可以看到在 CopyOnWriteArrayList 迭代之前，数组的内存地址是 962，请记住这个数字：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/18.jpeg" alt="18"></p></li> <li><p>CopyOnWriteArrayList 迭代之后，我们使用 add(“50”) 代码给数组新增一个数据后，数组内存地址发生了变化，内存地址从原来的 962 变成了 968，这是因为 CopyOnWriteArrayList 的 add 操作，会生成新的数组，所以数组的内存地址发生了变化：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/19.jpeg" alt="19"></p></li> <li><p>迭代继续进行时，我们发现迭代器中的地址仍然是迭代之前引用的地址，是 962，而不是新的数组的内存地址：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/20.jpeg" alt="20"></p></li></ol> <p>从上面 4 张截图，我们可以得到迭代过程中，即使 CopyOnWriteArrayList 的结构发生变动了，也不会抛出 ConcurrentModificationException 异常的原因：CopyOnWriteArrayList 迭代持有的是老数组的引用，而 CopyOnWriteArrayList 每次的数据变动，都会产生新的数组，对老数组的值不会产生影响，所以迭代也可以正常进行。</p> <p><strong>6 总结</strong></p> <p>当我们需要在线程不安全场景下使用 List 时，建议使用 CopyOnWriteArrayList，CopyOnWriteArrayList 通过锁 + 数组拷贝 + volatile 之间的相互配合，实现了 List 的线程安全，我们抛弃 Java 的这种实现，如果让我们自己实现，你又将如何实现呢？</p> <h3 id="_16-concurrenthashmap-源码解析和设计思路"><a href="#_16-concurrenthashmap-源码解析和设计思路" class="header-anchor">#</a> 16 ConcurrentHashMap 源码解析和设计思路</h3> <p><strong>引导语</strong></p> <p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p> <p><strong>1 类注释</strong></p> <p>我们从类注释上大概可以得到如下信息：</p> <ol><li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li> <li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li> <li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li> <li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li> <li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li></ol> <p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码。</p> <p><strong>2 结构</strong></p> <p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/21.jpeg" alt="21">
看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p> <p>ConcurrentHashMap 和 HashMap 两者的相同之处：</p> <ol><li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li> <li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li></ol> <p>不同之处：</p> <ol><li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li> <li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li></ol> <p><strong>3 put</strong></p> <p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p> <ol><li>如果数组为空，初始化，初始化完成之后，走 2；</li> <li>计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3；</li> <li>如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4；</li> <li>槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</li> <li>新增完成之后 check 需不需要扩容，需要的话去扩容。</li></ol> <p>具体源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> value <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">//计算hash</span>
       <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
           <span class="token comment">//table是空的，进行初始化</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
               tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">//如果当前索引位置没有值，直接创建</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment">//cas 在 i 位置创建新的元素，当 i 位置是空时，即能创建成功，结束for自循，否则继续自旋</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                            <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                   <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment">// no lock when adding to empty bin</span>
           <span class="token punctuation">}</span>
           <span class="token comment">//如果当前槽点是转移节点，表示该槽点正在扩容，就会一直等待扩容完成</span>
           <span class="token comment">//转移节点的 hash 值是固定的，都是 MOVED</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
               tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token comment">//槽点上有值的</span>
           <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token class-name">V</span> oldVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
               <span class="token comment">//锁定当前槽点，其余线程不能操作，保证了安全</span>
               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token comment">//这里再次判断 i 索引位置的数据没有被修改</span>
                   <span class="token comment">//binCount 被赋值的话，说明走到了修改表的过程里面</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">//链表</span>
                       <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
                               <span class="token comment">//值有的话，直接返回</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                   <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                    <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                   oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                       e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                   <span class="token keyword">break</span><span class="token punctuation">;</span>
                               <span class="token punctuation">}</span>
                               <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                               <span class="token comment">//把新增的元素赋值到链表的最后，退出自旋</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                   pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                             value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                                   <span class="token keyword">break</span><span class="token punctuation">;</span>
                               <span class="token punctuation">}</span>
                           <span class="token punctuation">}</span>
                       <span class="token punctuation">}</span>
                       <span class="token comment">//红黑树，这里没有使用 TreeNode,使用的是 TreeBin，TreeNode 只是红黑树的一个节点</span>
                       <span class="token comment">//TreeBin 持有红黑树的引用，并且会对其加锁，保证其操作的线程安全</span>
                       <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span>
                           binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                           <span class="token comment">//满足if的话，把老的值给oldVal</span>
                           <span class="token comment">//在putTreeVal方法里面，在给红黑树重新着色旋转的时候</span>
                           <span class="token comment">//会锁住红黑树的根节点</span>
                           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                          value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                   p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                       <span class="token punctuation">}</span>
                   <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
               <span class="token comment">//binCount不为空，并且 oldVal 有值的情况，说明已经新增成功了</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token comment">// 链表是否需要转化成红黑树</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>
                       <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                       <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                   <span class="token comment">//这一步几乎走不到。槽点已经上锁，只有在红黑树或者链表新增失败的时候</span>
                   <span class="token comment">//才会走到这里，这两者新增都是自旋的，几乎不会失败</span>
                   <span class="token keyword">break</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token comment">//check 容器是否需要扩容，如果需要去扩容，调用 transfer 方法去扩容</span>
       <span class="token comment">//如果已经在扩容中了，check有无完成</span>
       <span class="token function">addCount</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br></div></div><p>源码中都有非常详细的注释，就不解释了，我们重点说一下，ConcurrentHashMap 在 put 过程中，采用了哪些手段来保证线程安全。</p> <p><strong>3.1 数组初始化时的线程安全</strong></p> <p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
       <span class="token comment">//通过自旋保证初始化成功</span>
       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">// 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token keyword">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lost initialization race; just spin</span>
           <span class="token comment">// CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化</span>
           <span class="token comment">// 保证了数组的初始化的安全性</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">try</span> <span class="token punctuation">{</span>
                   <span class="token comment">// 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token comment">// 进行初始化</span>
                       <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>
                       <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
                       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                       table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                       sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token punctuation">}</span>
               <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                   sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token keyword">break</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p><strong>3.2 新增槽点值时的线程安全</strong></p> <p>此时为了保证线程安全，做了四处优化：</p> <ol><li>通过自旋死循环保证一定可以新增成功。</li></ol> <p>在新增之前，通过 for (Node&lt;K,V&gt;[] tab = table;😉 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p> <ol start="2"><li>当前槽点为空时，通过 CAS 新增。</li></ol> <p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p> <ol start="3"><li>当前槽点有值，锁住当前槽点。</li></ol> <p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改，截图如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/22.jpeg" alt="22"></p> <p>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转，代码截图如下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/23.jpeg" alt="23">
通过以上 4 点，保证了在各种情况下的新增（不考虑扩容的情况下），都是线程安全的，通过自旋 + CAS + 锁三大姿势，实现的很巧妙，值得我们借鉴。</p> <p><strong>3.3 扩容时的线程安全</strong></p> <p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法，transfer 方法的主要思路是：</p> <ol><li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</li> <li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</li> <li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</li> <li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</li> <li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol> <p>关键源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 扩容主要分 2 步，第一新建新的空数组，第二移动拷贝每个元素到新数组中去</span>
   <span class="token comment">// tab：原数组，nextTab：新数组</span>
   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 老数组的长度</span>
       <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>
           stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment">// subdivide range</span>
       <span class="token comment">// 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// initiating</span>
           <span class="token keyword">try</span> <span class="token punctuation">{</span>
               <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
               <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
               nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// try to cope with OOME</span>
               sizeCtl <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
               <span class="token keyword">return</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
           transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token comment">// 新数组的长度</span>
       <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
       <span class="token comment">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容</span>
       <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
       <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// to ensure sweep before committing nextTab</span>
       <span class="token comment">// 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>
           <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>
               <span class="token comment">// 结束循环的标志</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">&gt;=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
                   advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
               <span class="token comment">// 已经拷贝完成</span>
               <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                   advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token comment">// 每次减少 i 的值</span>
               <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span>compareAndSwapInt
                        <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                         nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">&gt;</span> stride <span class="token operator">?</span>
                                      nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>
                   i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                   advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token comment">// if 任意条件满足说明拷贝结束了</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">&gt;=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
               <span class="token comment">// 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷贝完成的节点的数据一定不会再发生变化。</span>
               <span class="token comment">// 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。</span>
               <span class="token comment">// 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任何线程安全的问题</span>
               <span class="token comment">// 所以此处直接赋值，没有任何问题。</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   nextTable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                   table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
                   sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token keyword">return</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>
                       <span class="token keyword">return</span><span class="token punctuation">;</span>
                   finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                   i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// recheck before commit</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
               advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
               advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// already processed</span>
           <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                   <span class="token comment">// 进行节点的拷贝</span>
                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>
                       <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                           <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                   runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                                   lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                               <span class="token punctuation">}</span>
                           <span class="token punctuation">}</span>
                           <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                               hn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                           <span class="token keyword">else</span> <span class="token punctuation">{</span>
                               hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                               ln <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                           <span class="token comment">// 如果节点只有单个数据，直接拷贝，如果是链表，循环多次组成链表拷贝</span>
                           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                               <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                   ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                               <span class="token keyword">else</span>
                                   hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           <span class="token punctuation">}</span>
                           <span class="token comment">// 在新数组位置上放置拷贝的值</span>
                           <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           <span class="token comment">// 在老数组位置上放上 ForwardingNode 节点</span>
                           <span class="token comment">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了</span>
                           <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                       <span class="token punctuation">}</span>
                       <span class="token comment">// 红黑树的拷贝</span>
                       <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                           <span class="token comment">// 红黑树的拷贝工作，同 HashMap 的内容，代码忽略</span>
                           …………
                           <span class="token comment">// 在老数组位置上放上 ForwardingNode 节点</span>
                           <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                           advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                       <span class="token punctuation">}</span>
                   <span class="token punctuation">}</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br><span class="line-number">109</span><br><span class="line-number">110</span><br><span class="line-number">111</span><br><span class="line-number">112</span><br><span class="line-number">113</span><br><span class="line-number">114</span><br><span class="line-number">115</span><br><span class="line-number">116</span><br><span class="line-number">117</span><br><span class="line-number">118</span><br><span class="line-number">119</span><br><span class="line-number">120</span><br><span class="line-number">121</span><br><span class="line-number">122</span><br><span class="line-number">123</span><br><span class="line-number">124</span><br><span class="line-number">125</span><br><span class="line-number">126</span><br></div></div><p>扩容中的关键点，就是如何保证是线程安全的，小结有如下几点：</p> <ol><li>拷贝槽点时，会把原数组的槽点锁住；</li> <li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li> <li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li> <li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put。</li></ol> <p>扩容方法还是很有意思的，通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p> <p><strong>4 get</strong></p> <p>ConcurrentHashMap 读的话，就比较简单，先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> <span class="token class-name">K</span> ek<span class="token punctuation">;</span>
       <span class="token comment">//计算hashcode</span>
       <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">//不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的</span>
       <span class="token comment">//否则该key对应的值不存在，返回null</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
           <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token comment">//槽点第一个值和key相等，直接返回</span>
           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                   <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           <span class="token comment">//如果是红黑树或者转移节点，使用对应的find方法</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
               <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
           <span class="token comment">//如果是链表，遍历查找</span>
           <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
                   <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                   <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p><strong>5 总结</strong></p> <p>本文摘取 ConcurrentHashMap 两个核心的方法讲解了一下，特别是 put 方法，采取了很多手段来保证了线程安全，是平时面试时的重中之重，大家可以尝试</p> <h3 id="_17-并发-list、map源码面试题"><a href="#_17-并发-list、map源码面试题" class="header-anchor">#</a> 17 并发 List、Map源码面试题</h3> <p><strong>引导语</strong></p> <p>并发 List 和 Map 是技术面时常问的问题，问的问题也都比较深入，有很多问题都是面试官自创的，市面上找不到，所以说通过背题的方式，这一关大部分是过不了的，只有我们真正理解了 API 内部的实现，阅读过源码，才能自如应对各种类型的面试题，接着我们来看一下并发 List、Map 源码相关的面试题集。</p> <p><strong>1 CopyOnWriteArrayList 相关</strong></p> <p><strong>1.1 和 ArrayList 相比有哪些相同点和不同点？</strong></p> <p>答：相同点：底层的数据结构是相同的，都是数组的数据结构，提供出来的 API 都是对数组结构进行操作，让我们更好的使用。</p> <p>不同点：后者是线程安全的，在多线程环境下使用，无需加锁，可直接使用。</p> <p><strong>1.2 CopyOnWriteArrayList 通过哪些手段实现了线程安全？</strong></p> <p>答：主要有：</p> <ol><li>数组容器被 volatile 关键字修饰，保证了数组内存地址被任意线程修改后，都会通知到其他线程；</li> <li>对数组的所有修改操作，都进行了加锁，保证了同一时刻，只能有一个线程对数组进行修改，比如我在 add 时，就无法 remove；</li> <li>修改过程中对原数组进行了复制，是在新数组上进行修改的，修改过程中，不会对原数组产生任何影响。</li></ol> <p>通过以上三点保证了线程安全。</p> <p><strong>1.3 在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？</strong></p> <p>答：的确，对数组进行加锁后，能够保证同一时刻，只有一个线程能对数组进行 add，在同单核 CPU 下的多线程环境下肯定没有问题，但我们现在的机器都是多核 CPU，如果我们不通过复制拷贝新建数组，修改原数组容器的内存地址的话，是无法触发 volatile 可见性效果的，那么其他 CPU 下的线程就无法感知数组原来已经被修改了，就会引发多核 CPU 下的线程安全问题。</p> <p>假设我们不复制拷贝，而是在原来数组上直接修改值，数组的内存地址就不会变，而数组被 volatile 修饰时，必须当数组的内存地址变更时，才能及时的通知到其他线程，内存地址不变，仅仅是数组元素值发生变化时，是无法把数组元素值发生变动的事实，通知到其它线程的。</p> <p><strong>1.4 对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？</strong></p> <p>答：主要有：</p> <ol><li>在批量操作时，尽量使用 addAll、removeAll 方法，而不要在循环里面使用 add、remove 方法，主要是因为 for 循环里面使用 add 、remove 的方式，在每次操作时，都会进行一次数组的拷贝(甚至多次)，非常耗性能，而 addAll、removeAll 方法底层做了优化，整个操作只会进行一次数组拷贝，由此可见，当批量操作的数据越多时，批量方法的高性能体现的越明显。</li></ol> <p><strong>1.5 为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了</strong></p> <p>答：主要是因为 CopyOnWriteArrayList 每次操作时，都会产生新的数组，而迭代时，持有的仍然是老数组的引用，所以我们说的数组结构变动，是用新数组替换了老数组，老数组的结构并没有发生变化，所以不会抛出异常了。</p> <p><strong>1.6 插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？</strong></p> <p>答：ArrayList 只需拷贝一次，假设插入的位置是 2，只需要把位置 2 （包含 2）后面的数据都往后移动一位即可，所以拷贝一次。</p> <p>CopyOnWriteArrayList 拷贝两次，因为 CopyOnWriteArrayList 多了把老数组的数据拷贝到新数组上这一步，可能有的同学会想到这种方式：先把老数组拷贝到新数组，再把 2 后面的数据往后移动一位，这的确是一种拷贝的方式，但 CopyOnWriteArrayList 底层实现更加灵活，而是：把老数组 0 到 2 的数据拷贝到新数组上，预留出新数组 2 的位置，再把老数组 3～ 最后的数据拷贝到新数组上，这种拷贝方式可以减少我们拷贝的数据，虽然是两次拷贝，但拷贝的数据却仍然是老数组的大小，设计的非常巧妙。</p> <p><strong>2 ConcurrentHashMap 相关</strong></p> <p><strong>2.1ConcurrentHashMap 和 HashMap 的相同点和不同点</strong></p> <p>答：
相同点：</p> <ol><li>都是数组 + 链表 +红黑树的数据结构，所以基本操作的思想相同；</li> <li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以两者的方法大多都是相似的，可以互相切换。</li></ol> <p>不同点：</p> <ol><li>ConcurrentHashMap 是线程安全的，在多线程环境下，无需加锁，可直接使用；</li> <li>数据结构上，ConcurrentHashMap 多了转移节点，主要用于保证扩容时的线程安全。</li></ol> <p><strong>2.2 ConcurrentHashMap 通过哪些手段保证了线程安全。</strong></p> <p>答：主要有以下几点：</p> <ol><li>储存 Map 数据的数组被 volatile 关键字修饰，一旦被修改，立马就能通知其他线程，因为是数组，所以需要改变其内存值，才能真正的发挥出 volatile 的可见特性；</li> <li>put 时，如果计算出来的数组下标索引没有值的话，采用无限 for 循环 + CAS 算法，来保证一定可以新增成功，又不会覆盖其他线程 put 进去的值；</li> <li>如果 put 的节点正好在扩容，会等待扩容完成之后，再进行 put ，保证了在扩容时，老数组的值不会发生变化；</li> <li>对数组的槽点进行操作时，会先锁住槽点，保证只有当前线程才能对槽点上的链表或红黑树进行操作；</li> <li>红黑树旋转时，会锁住根节点，保证旋转时的线程安全。</li></ol> <p><strong>2.3 描述一下 CAS 算法在 ConcurrentHashMap 中的应用？</strong></p> <p>答：CAS 其实是一种乐观锁，一般有三个值，分别为：赋值对象，原值，新值，在执行的时候，会先判断内存中的值是否和原值相等，相等的话把新值赋值给对象，否则赋值失败，整个过程都是原子性操作，没有线程安全问题。</p> <p>ConcurrentHashMap 的 put 方法中，有使用到 CAS ，是结合无限 for 循环一起使用的，步骤如下：</p> <ol><li>计算出数组索引下标，拿出下标对应的原值；</li> <li>CAS 覆盖当前下标的值，赋值时，如果发现内存值和 1 拿出来的原值相等，执行赋值，退出循环，否则不赋值，转到 3；</li> <li>进行下一次 for 循环，重复执行 1，2，直到成功为止。
可以看到这样做的好处，第一是不会盲目的覆盖原值，第二是一定可以赋值成功。</li></ol> <p><strong>2.4 ConcurrentHashMap 是如何发现当前槽点正在扩容的。</strong></p> <p>答：ConcurrentHashMap 新增了一个节点类型，叫做转移节点，当我们发现当前槽点是转移节点时（转移节点的 hash 值是 -1），即表示 Map 正在进行扩容。</p> <p><strong>2.5 发现槽点正在扩容时，put 操作会怎么办?</strong></p> <p>答：无限 for 循环，或者走到扩容方法中去，帮助扩容，一直等待扩容完成之后，再执行 put 操作。</p> <p><strong>2.6 两种 Map 扩容时，有啥区别？</strong></p> <p>答：区别很大，HashMap 是直接在老数据上面进行扩容，多线程环境下，会有线程安全的问题，而 ConcurrentHashMap 就不太一样，扩容过程是这样的：</p> <ol><li>从数组的队尾开始拷贝；</li> <li>拷贝数组的槽点时，先把原数组槽点锁住，拷贝成功到新数组时，把原数组槽点赋值为转移节点；</li> <li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组的槽点设置成转移节点；</li> <li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol> <p>简单来说，通过扩容时给槽点加锁，和发现槽点正在扩容就等待的策略，保证了 ConcurrentHashMap 可以慢慢一个一个槽点的转移，保证了扩容时的线程安全，转移节点比较重要，平时问的人也比较多。</p> <p><strong>2.7 ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？</strong></p> <p>答：非常不一样，拿 put 方法为例，Java 7 的做法是：</p> <ol><li>把数组进行分段，找到当前 key 对应的是那一段；</li> <li>将当前段锁住，然后再根据 hash 寻找对应的值，进行赋值操作。</li></ol> <p>Java 7 的做法比较简单，缺点也很明显，就是当我们需要 put 数据时，我们会锁住改该数据对应的某一段，这一段数据可能会有很多，比如我只想 put 一个值，锁住的却是一段数据，导致这一段的其他数据都不能进行写入操作，大大的降低了并发性的效率。Java 8 解决了这个问题，从锁住某一段，修改成锁住某一个槽点，提高了并发效率。</p> <p>不仅仅是 put，删除也是，仅仅是锁住当前槽点，缩小了锁的范围，增大了效率。</p> <p><strong>3 总结</strong></p> <p>因为目前大多数公司都已经在使用 Java 8 了，所以大部分面试内容还是以 Java 8 的 API 为主，特别是 CopyOnWriteArrayList 和 ConcurrentHashMap 两个 API，文章毕竟篇幅有限，建议大家多多阅读剩余源码。</p> <h3 id="_18-场景集合：并发-list、map的应用场景"><a href="#_18-场景集合：并发-list、map的应用场景" class="header-anchor">#</a> 18 场景集合：并发 List、Map的应用场景</h3> <p><strong>引导语</strong></p> <p>并发 List、Map 使用最多的就是 CopyOnWriteArrayList 和 ConcurrentHashMap，在考虑 API 时，我们也无需迟疑，这两个并发类在安全和性能方面都很好，我们都可以直接使用。</p> <p>并发的场景很多，但归根结底其实就是共享变量被多个线程同时访问，也就是说 CopyOnWriteArrayList 或 ConcurrentHashMap 会被作为共享变量，本节我们会以流程引擎为案例，现身说法，增加一下大家的工作经验积累。</p> <p>流程引擎在实际工作中经常被使用，其主要功能就是对我们需要完成的事情，进行编排和组装，比如在淘宝下单流程中，我们一共会执行 20 个 Spring Bean，流程引擎就可以帮助我们调起 20 个 Spring Bean，并帮助我们去执行，本文介绍的重点在于如何使用 Map + List 来设计流程引擎的数据结构，以及其中需要注意到的线程安全的问题。</p> <p><strong>1 嵌套 Map，简单流程引擎</strong></p> <p>市面上有很多流程引擎，比如说 Activiti、Flowable、Camunda 等等，功能非常齐全，但我们本小节只实现一种最最简单的流程引擎，只要能对我们需要完成的事情进行编排，并能依次的调用就行。</p> <p>1.1 流程引擎设计思路
我们认为每个流程都会做 4 个阶段的事情，阶段主要是指在整个流程中，大概可以分为几个大的步骤，每个阶段可以等同为大的步骤，分别如下：</p> <ol><li>参数校验，主要是对流程的入参数进行校验；</li> <li>业务校验，主要是对当前流程中的业务进行逻辑校验；</li> <li>事务中落库，主要把数据落库，控制事务；</li> <li>事务后事件，我们在数据落库，事务提交之后，可能会做一些其他事情，比如说发消息出来等等。</li></ol> <p>以上每个大的阶段，都会做一些粒度较细的事情，比如说业务校验，我们可能会对两个业务对象进行校验，那么此时业务校验阶段就会做两件事情，每件具体的事情，我们叫做领域行为，在实际项目中，一个领域行为一般都是一个 Spring Bean。</p> <p>综上所述，流程引擎嵌套数据结构就是：流程 -&gt; 阶段 -&gt; 领域行为，前者对应后者，都是一对一或者一对多的关系。</p> <p>我们以在淘宝上买东西时，下单为例，下单指的是我们在淘宝选择好了商品和优惠券后，点击购买按钮时触发的动作。</p> <p>为了方便举例，我们假设在淘宝上买电视和电影票，在后端，会分别对应着两个下单流程，我们画图示意一下：
<img src="/Java%E6%BA%90%E7%A0%81%E5%8F%8A%E5%A4%A7%E5%8E%82%E7%9C%9F%E9%A2%98/02%E9%9B%86%E5%90%88/24.jpeg" alt="24"></p> <p>上图中，左右两个黑色长方形大框代表着两个流程，流程下面有多个阶段，阶段用蓝色表示，每个阶段下面有多个领域行为，用红色表示。</p> <p>可以看到两个流程中，都包含有四个阶段，阶段都是相同的，但每个阶段中的领域行为，有的相同，有的却是特有的。</p> <p>三个概念，每个概念层层嵌套，整体组装起来，用来表示一个流程，那么这个数据结构，我们应该如何表示呢？</p> <p>使用 Map + List 即可！</p> <p><strong>1.2 数据结构的定义</strong></p> <p>流程的数据结构定义分成两步：</p> <p>定义出阶段、领域行为基础概念；
把阶段、领域行为、流程概念组合起来，定义出流程的数据结构。
首先给阶段定义一个枚举，如下 StageEnum 代表流程中的阶段或步骤：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">StageEnum</span> <span class="token punctuation">{</span>
     <span class="token function">PARAM_VALID</span><span class="token punctuation">(</span><span class="token string">&quot;PARAM_VALID&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;参数校验&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   
     <span class="token function">BUSINESS_VALID</span><span class="token punctuation">(</span><span class="token string">&quot;BUSINESS_VALID&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;业务校验&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   
     <span class="token function">IN_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">&quot;IN_TRANSACTION&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;事务中落库&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   
     <span class="token function">AFTER_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">&quot;AFTER_TRANSACTION&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;事务后事件&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token punctuation">;</span>
   
     <span class="token keyword">private</span> <span class="token class-name">String</span> code<span class="token punctuation">;</span>
     <span class="token keyword">private</span> <span class="token class-name">String</span> desc<span class="token punctuation">;</span>
   
     <span class="token class-name">StageEnum</span><span class="token punctuation">(</span><span class="token class-name">String</span> code<span class="token punctuation">,</span> <span class="token class-name">String</span> desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
       <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>领域行为我们无需定义，目前通用的技术框架都是 Spring Boot，领域行为都是 Spring Bean，为了简单起见，我们给领域行为定义了一个接口，每个领域行为都要实现这个接口，方便我们编排，接口如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">/**
    * 领域行为
    * author  wenhe
    * date 2019/8/11
    */</span>
   <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DomainAbilityBean</span> <span class="token punctuation">{</span>
   
     <span class="token comment">/**
      * 领域行为的方法入口
      */</span>
     <span class="token class-name">FlowContent</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>接着我们使用 Map + List 来定义流程，定义如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">/**
    * 第一个 key 是流程的名字
    * 第二个 map 的 key 是阶段，为 StageEnum 枚举，值为多个领域行为的集合
    */</span>
   <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">StageEnum</span><span class="token punctuation">,</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">DomainAbilityBean</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> flowMap

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>至此，我们定义出了，简单流程引擎的数据结构，流程引擎看着很复杂，利用 Map + List 的组合，就巧妙的定义好了。</p> <p><strong>2 容器初始化时，本地缓存使用</strong></p> <p>我们定义好 Map 后，我们就需要去使用他，我们使用的大体步骤为：</p> <p>项目启动时，把所有的流程信息初始化到 flowMap(刚刚定义的流程的数据结构叫做 flowMap) 中去，可能是从数据库中加载，也可能是从 xml 文件中加载；
查找流程时，直接从 flowMap 中获取即可。</p> <p><strong>2.1 初始化</strong></p> <p>以上两步最为关键的点就是 flowMap 必须是可以随时访问到的，所有我们会把 flowMap 作为共享变量使用，也就是会被 static final 关键字所修饰，我们首先来 mock 一下把所有信息初始化到 flowMap 中去的代码，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token annotation punctuation">@Component</span>
   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCenter</span> <span class="token punctuation">{</span>
   
     <span class="token comment">/**
      * flowMap 是共享变量，方便访问，并且是 ConcurrentHashMap
      */</span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">StageEnum</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">DomainAbilityBean</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> flowMap
         <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   
     <span class="token comment">/**
      * PostConstruct 注解的意思就是
      * 在容器启动成功之后，执行 init 方法，初始化 flowMap
      */</span>
     <span class="token annotation punctuation">@PostConstruct</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 初始化 flowMap，可能是从数据库，或者 xml 文件中加载 map</span>
     <span class="token punctuation">}</span>
   
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>以上代码，关键地方在于三点：</p> <ol><li>flowMap 被 static final 修饰，是个共享变量，方便访问；</li> <li>flowMap 是 ConcurrentHashMap，所以我们所有的操作都无需加锁，比如我们在 init 方法中，对 flowMap 进行初始化，就无需加锁，因为 ConcurrentHashMap 本身已经保证了线程安全；</li> <li>这里我们初始化的时机是在容器启动的时候，在实际的工作中，我们经常在容器启动的时候，把不会经常发生变动的数据，放到类似 List、Map 这样的共享变量中，这样当我们频繁要使用的时候，直接从内存中读取即可。</li></ol> <p><strong>2.2 使用</strong></p> <p>那我们实际使用的时候，只需要告诉 flowMap 当前是那个流程的那个阶段，就可以返回该流程该阶段下面的所有领域行为了，我们写了一个流程引擎使用的工具类入口，如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token comment">// 流程引擎对外的 API</span>
   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowStart</span> <span class="token punctuation">{</span>
   
     <span class="token comment">/**
      * 流程引擎开始
      *
      * @param flowName 流程的名字
      */</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">invokeParamValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 执行参数校验</span>
     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeParamValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> <span class="token class-name">StageEnum</span><span class="token punctuation">.</span>PARAM_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 执行业务校验</span>
     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> <span class="token class-name">StageEnum</span><span class="token punctuation">.</span>BUSINESS_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 执行事务中</span>
     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> <span class="token class-name">StageEnum</span><span class="token punctuation">.</span>IN_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// 执行事务后</span>
     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> <span class="token class-name">StageEnum</span><span class="token punctuation">.</span>AFTER_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
   		
     <span class="token comment">// 批量执行 Spring Bean</span>
     <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stageInvoke</span><span class="token punctuation">(</span><span class="token class-name">String</span> flowName<span class="token punctuation">,</span> <span class="token class-name">StageEnum</span> stage<span class="token punctuation">,</span> <span class="token class-name">FlowContent</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DomainAbilityBean</span><span class="token punctuation">&gt;</span></span>
           domainAbilitys <span class="token operator">=</span>
           <span class="token class-name">FlowCenter</span><span class="token punctuation">.</span>flowMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stage<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">CollectionUtils</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;找不到该流程对应的领域行为&quot;</span> <span class="token operator">+</span> flowName<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DomainAbilityBean</span> domainAbility <span class="token operator">:</span> domainAbilitys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         domainAbility<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
   
   <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><p>从代码中可以看到，我们在流程引擎的入口，只要根据参数校验、业务校验、事务中、事务后四个阶段，从 flowMap 中得到领域行为的集合，然后对领域行为进行顺序执行即可。</p> <p>我们在使用时，直接使用上述类的 start 方法即可。</p> <p>当然以上演示的流程引擎只是一个大的框架，还有很多地方需要改进的地方，比如如何找到 flowName，如何初始化 flowMap，但这些都不是本节重点，本节主要想通过流程引擎案例来说明几点：</p> <ol><li>把 List 和 Map 作为共享变量非常常见，就像咱们这种项目启动时，从数据库中把数据捞出来，然后封装成 List 或 Map 的结构，这样做的优点就是节约资源，不用每次用的时候都去查数据库，直接从内存中获取即可；</li> <li>并发场景下，我们可以放心的使用 CopyOnWriteArrayList 和 ConcurrentHashMap 两个并发类，首先用 static final 对两者进行修饰，使其成为共享变量，接着在写入或者查询的时候，无需加锁，两个 API 内部已经实现了加锁的功能了；</li> <li>有一点需要澄清一下，就是 CopyOnWriteArrayList 和 ConcurrentHashMap 只能作为单机的共享变量，如果是分布式系统，多台机器的情况下，这样做不行了，需要使用分布式缓存了。</li></ol> <p><strong>3 总结</strong></p> <p>本节内容，以流程引擎为例，说明了如何使用 Map + List 的嵌套结构设计流程引擎，以及在并发情况下，如何安全的使用 List 和 Map。</p> <p>本案列是高并发项目的真实案例，感兴趣的同学可以在此流程引擎框架基础上进行细节补充，实现可运行的流程引擎。</p> <h2 id="第4章-队列"><a href="#第4章-队列" class="header-anchor">#</a> 第4章 队列</h2> <h3 id="_19-linkedblockingqueue-源码解析"><a href="#_19-linkedblockingqueue-源码解析" class="header-anchor">#</a> 19 LinkedBlockingQueue 源码解析</h3></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----></main> <!----> <div class="comments-wrapper" data-v-4698c43e><!----></div></div></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-a81d141e data-v-a81d141e><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-a81d141e><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-a81d141e></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-a81d141e></path></svg></div></div></div>
    <script src="/assets/js/app.c5a7abc6.js" defer></script><script src="/assets/js/3.4c596803.js" defer></script><script src="/assets/js/1.bddbeb83.js" defer></script><script src="/assets/js/11.d44f14ae.js" defer></script>
  </body>
</html>
